<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC</title>
    <url>/2021/06/12/BFC/</url>
    <content><![CDATA[<h2 id="1-BFC-块级格式化上下文"><a href="#1-BFC-块级格式化上下文" class="headerlink" title="1.BFC(块级格式化上下文)"></a>1.BFC(块级格式化上下文)</h2><p>BFC(Block formatting context)</p>
<p>直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<span id="more"></span>

<h3 id="1-1-什么情况下可以让元素产生BFC"><a href="#1-1-什么情况下可以让元素产生BFC" class="headerlink" title="1.1 什么情况下可以让元素产生BFC"></a>1.1 什么情况下可以让元素产生BFC</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>根元素</span><br><span class="line"><span class="number">2.f</span>loat属性不为none</span><br><span class="line"><span class="number">3.</span>position为absolute或fixed</span><br><span class="line"><span class="number">4.</span>display为<span class="keyword">inline</span>-block, table-cell, table-caption, flex, <span class="keyword">inline</span>-flex</span><br><span class="line"><span class="number">5.</span>overflow不为visible。</span><br><span class="line"></span><br><span class="line">但其中，最常见的就是overflow:hidden、<span class="keyword">float</span>:left/right、position:absolute。也就是说每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</span><br><span class="line"></span><br><span class="line">注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们暂且不研究。</span><br></pre></td></tr></table></figure>

<p>虽然添加上述的任意一条都能创建BFC，但会有一些副作用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.display</span>: <span class="selector-tag">table</span> 可能引发响应性问题</span><br><span class="line"><span class="number">2</span><span class="selector-class">.overflow</span>: scroll 可能产生多余的滚动条</span><br><span class="line"><span class="number">3</span><span class="selector-class">.float</span>: <span class="attribute">left</span> 将把元素移至左侧，并被其他元素环绕</span><br><span class="line"><span class="number">4</span><span class="selector-class">.overflow</span>: hidden 将裁切溢出元素</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们一般通过overflow:hidden来开启BFC</p>
<h3 id="1-2-BFC元素所具有的特性"><a href="#1-2-BFC元素所具有的特性" class="headerlink" title="1.2 BFC元素所具有的特性"></a>1.2 BFC元素所具有的特性</h3><p>BFC布局规则特性：</p>
<p>1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.</p>
<p>2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>
<p>4.BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</p>
<p>5.计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p>
<p>6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</p>
<h3 id="1-3-BFC的主要用途"><a href="#1-3-BFC的主要用途" class="headerlink" title="1.3 BFC的主要用途"></a>1.3 BFC的主要用途</h3><p>BFC能用来做什么？</p>
<p>(1) 清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p>
<p>主要用到 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/12/BFC/BFC%5Cfu.jpg"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;par&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;child&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;child&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.par</span> &#123;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>(2) 解决外边距合并问题</p>
<p>外边距合并的问题。</p>
<p>主要用到 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">盒子垂直方向的距离由<span class="attribute">margin</span>决定。属于同一个BFC的两个相邻盒子的<span class="attribute">margin</span>会发生重叠</span><br></pre></td></tr></table></figure>

<p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
<p><img src="/2021/06/12/BFC/BFC%5Cma.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt;Haha&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">p</span>&gt;Hehe&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.wrap</span> &#123;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">text-align</span>:center;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>(3) 制作右侧自适应的盒子问题</p>
<p>主要用到 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/12/BFC/BFC%5Cyou.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">aside</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">main</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-class">.aside</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#f66</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-class">.main</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>(4) 消除子元素浮动对父元素的兄弟的文字布局产生的影响</p>
<p>​    当浮动的子元素的高度大于父亲的高度的时候，此时会对父亲后面的兄弟中文字布局产生影响，父亲后面兄弟中的文字会贴着浮动的子元素后面进行布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">   <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">height</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">background</span>:yellow;</span></span><br><span class="line"><span class="css">       <span class="attribute">overflow</span>:hidden;<span class="comment">/*开启BFC，彻底消除parent里面元素对外面布局产生的影响*/</span></span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css">   </span></span><br><span class="line"><span class="css">   <span class="selector-class">.parent</span> <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">height</span>:<span class="number">350px</span>;</span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-BFC-总结"><a href="#1-4-BFC-总结" class="headerlink" title="1.4 BFC 总结"></a>1.4 BFC 总结</h3><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等。</p>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas贪吃蛇</title>
    <url>/2021/06/10/canvas%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<img src="/2021/06/10/canvas%E8%B4%AA%E5%90%83%E8%9B%87/tc.png" style="zoom:67%;">

<span id="more"></span>

<h1 id="Food"><a href="#Food" class="headerlink" title="Food()"></a>Food()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//食物的自调用函数</span></span><br><span class="line">(function (w) &#123;</span><br><span class="line">    <span class="comment">//食物的构造函数</span></span><br><span class="line">    function Food(x, y, width, height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.y = y || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.width = width || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.height = height || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.q = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//食物的初始化方法</span></span><br><span class="line">    <span class="keyword">var</span> image = new Image();</span><br><span class="line">    image.src = <span class="string">&quot;images/bianbian.png&quot;</span>;</span><br><span class="line">    Food.prototype.<span class="keyword">init</span> = function (ctx, x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.q = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定食物的坐标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.q == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> maxX = Math.floor(ctx.canvas.width / <span class="keyword">this</span>.width);</span><br><span class="line">            <span class="keyword">var</span> maxY = Math.floor(ctx.canvas.height / <span class="keyword">this</span>.height);</span><br><span class="line">            x = Random.getRandom(<span class="number">0</span>, maxX);</span><br><span class="line">            y = Random.getRandom(<span class="number">0</span>, maxY);</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.q = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建页面元素</span></span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.drawImage(image, <span class="keyword">this</span>.x * <span class="number">40</span>, <span class="keyword">this</span>.y * <span class="number">40</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">        <span class="comment">// ctx.fillStyle = this.color;</span></span><br><span class="line">        <span class="comment">// ctx.fillRect(this.x*40, this.y*40, this.width, this.height);</span></span><br><span class="line">    &#125;;</span><br><span class="line">    w.Food = Food;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="Snake"><a href="#Snake" class="headerlink" title="Snake()"></a>Snake()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//蛇的自调用函数</span></span><br><span class="line">(function (w) &#123;</span><br><span class="line">    <span class="keyword">var</span> sco = document.querySelector(<span class="string">&quot;.sco&quot;</span>);</span><br><span class="line">    <span class="comment">//小蛇的构造函数</span></span><br><span class="line">    function Snake(width, height, direction) &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.height = height || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.direction = direction || <span class="string">&quot;right&quot;</span>;</span><br><span class="line">        <span class="comment">//游戏分数统计</span></span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        sco.innerText = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="comment">//小蛇身躯</span></span><br><span class="line">        <span class="keyword">this</span>.body = [</span><br><span class="line">            &#123; x: <span class="number">3</span>, y: <span class="number">2</span>, color: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">            &#123; x: <span class="number">2</span>, y: <span class="number">2</span>, color: <span class="string">&quot;green&quot;</span> &#125;,</span><br><span class="line">            &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, color: <span class="string">&quot;green&quot;</span> &#125;,</span><br><span class="line">            <span class="comment">// &#123; x: 3, y: 2, color: &quot;images/header.png&quot; &#125;,</span></span><br><span class="line">            <span class="comment">// &#123; x: 2, y: 2, color: &quot;images/body.png&quot; &#125;,</span></span><br><span class="line">            <span class="comment">// &#123; x: 1, y: 2, color: &quot;images/body.png&quot; &#125;,</span></span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小蛇的初始化方法</span></span><br><span class="line"></span><br><span class="line">    Snake.prototype.<span class="keyword">init</span> = function (ctx) &#123;</span><br><span class="line">        <span class="comment">//创建小蛇的每一个身躯</span></span><br><span class="line">        <span class="keyword">var</span> image = new Image();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">            <span class="comment">//创建页面元素</span></span><br><span class="line">            <span class="comment">// image.src = this.body[i].color;</span></span><br><span class="line">            <span class="comment">// ctx.drawImage(image, this.body[i].x * 40, this.body[i].y * 40, this.width, this.height);</span></span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.fillStyle = <span class="keyword">this</span>.body[i].color;</span><br><span class="line">            ctx.fillRect(<span class="keyword">this</span>.body[i].x * <span class="number">40</span>, <span class="keyword">this</span>.body[i].y * <span class="number">40</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// image.src = this.body[0].color;</span></span><br><span class="line">        <span class="comment">// var that=this;</span></span><br><span class="line">        <span class="comment">// image.onload = function () &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(that);</span></span><br><span class="line">        <span class="comment">//     for (var i = 0; i &lt; that.body.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//         if(i==0)&#123;</span></span><br><span class="line">        <span class="comment">//             console.log(i);</span></span><br><span class="line">        <span class="comment">//             ctx.drawImage(image, that.body[i].x * 40, that.body[i].y * 40, that.width, that.height);</span></span><br><span class="line">        <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//             image.src = that.body[1].color;</span></span><br><span class="line">        <span class="comment">//             console.log(image);</span></span><br><span class="line">        <span class="comment">//             ctx.drawImage(image, that.body[i].x * 40, that.body[i].y * 40, that.width, that.height);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ctx.beginPath();</span></span><br><span class="line">        <span class="comment">// ctx.fillStyle = this.body[i].color;</span></span><br><span class="line">        <span class="comment">// ctx.fillRect(this.body[i].x * 40, this.body[i].y * 40, this.width, this.height);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//小蛇移动的方法</span></span><br><span class="line">    Snake.prototype.move = function (ctx, food) &#123;</span><br><span class="line">        <span class="comment">//改变非蛇头部分坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.body.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.body[i].x = <span class="keyword">this</span>.body[i - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">this</span>.body[i].y = <span class="keyword">this</span>.body[i - <span class="number">1</span>].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改变蛇头部分坐标</span></span><br><span class="line">        switch (<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">            case <span class="string">&quot;right&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].x += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;left&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].x -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;up&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].y -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;down&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].y += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当蛇头坐标和食物坐标重叠的时候，就可以吃食物了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.body[<span class="number">0</span>].x === food.x &amp;&amp; <span class="keyword">this</span>.body[<span class="number">0</span>].y === food.y) &#123;</span><br><span class="line">            <span class="comment">//让小蛇的身躯+1</span></span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">500</span>;</span><br><span class="line">            sco.innerText = <span class="keyword">this</span>.score;</span><br><span class="line">            <span class="keyword">var</span> last = <span class="keyword">this</span>.body[<span class="keyword">this</span>.body.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> item = &#123;</span><br><span class="line">                x: last.x,</span><br><span class="line">                y: last.y,</span><br><span class="line">                color: last.color,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">this</span>.body.push(item);</span><br><span class="line">            food.<span class="keyword">init</span>(ctx, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.body[i].x === food.x &amp;&amp; <span class="keyword">this</span>.body[i].y === food.y) &#123;</span><br><span class="line">                food.<span class="keyword">init</span>(ctx, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次移动就会删除之前的，重新生成</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">init</span>(ctx);</span><br><span class="line">    &#125;;</span><br><span class="line">    w.Snake = Snake;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="Game"><a href="#Game" class="headerlink" title="Game()"></a>Game()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(function (w) &#123;</span><br><span class="line">    function Game() &#123;</span><br><span class="line">        <span class="keyword">this</span>.food = new Food();</span><br><span class="line">        <span class="keyword">this</span>.snake = new Snake();</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    Game.prototype.startGame = function (ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">        <span class="keyword">this</span>.bindKey();</span><br><span class="line">        <span class="keyword">this</span>.time(ctx);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Game.prototype.time = function (ctx,w) &#123;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        i = w||<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(() =&gt; &#123;</span><br><span class="line">            ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctx.canvas.width, ctx.canvas.height);</span><br><span class="line">            <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">            <span class="keyword">this</span>.snake.move(ctx, <span class="keyword">this</span>.food);</span><br><span class="line">            <span class="keyword">this</span>.gameOver(ctx);</span><br><span class="line">        &#125;, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂停游戏</span></span><br><span class="line">    Game.prototype.pausee = function () &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定键盘的按键</span></span><br><span class="line">    Game.prototype.bindKey = function () &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        document.onkeydown = function (e) &#123;</span><br><span class="line">            <span class="keyword">var</span> e = e || window.event;</span><br><span class="line">            switch (e.keyCode) &#123;</span><br><span class="line">                <span class="comment">//上</span></span><br><span class="line">                case <span class="number">38</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;up&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;down&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;up&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                case <span class="number">39</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;right&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;left&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;right&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//下</span></span><br><span class="line">                case <span class="number">40</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;up&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;down&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;down&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                case <span class="number">37</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;right&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;left&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;left&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">3000</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> list=document.querySelectorAll(<span class="string">&quot;.aa&quot;</span>);</span><br><span class="line">    <span class="comment">//排行榜</span></span><br><span class="line">    Game.prototype.lists=function()&#123;</span><br><span class="line">        <span class="comment">//排行榜记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= <span class="keyword">this</span>.snake.score) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> x=arr.length-<span class="number">1</span>;x&gt;i;x--)&#123;</span><br><span class="line">                    arr[x]=arr[x-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i] = <span class="keyword">this</span>.snake.score;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            list[j].innerText=arr[j];</span><br><span class="line">            console.log(list[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断游戏结束</span></span><br><span class="line">    Game.prototype.gameOver = function (ctx) &#123;</span><br><span class="line">        <span class="comment">//游戏结束的判定条件</span></span><br><span class="line">        <span class="comment">//1.蛇头超出地图边界</span></span><br><span class="line">        <span class="keyword">var</span> head = <span class="keyword">this</span>.snake.body[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> maxX = Math.floor(ctx.canvas.width / <span class="keyword">this</span>.food.width);</span><br><span class="line">        <span class="keyword">var</span> maxY = Math.floor(ctx.canvas.height / <span class="keyword">this</span>.food.height);</span><br><span class="line">        <span class="keyword">if</span> (head.x &lt; <span class="number">0</span> || head.y &lt; <span class="number">0</span> || head.x &gt;= maxX || head.y &gt;= maxY) &#123;</span><br><span class="line">            clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">            <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.lists();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.蛇头撞到自己的身躯  遍历每一个身躯，看每一个身躯的坐标是否和蛇头重叠</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.snake.body.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> item = <span class="keyword">this</span>.snake.body[i];</span><br><span class="line">            <span class="comment">//头撞身躯了</span></span><br><span class="line">            <span class="keyword">if</span> (item.x === head.x &amp;&amp; item.y === head.y) &#123;</span><br><span class="line">                clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">                <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.lists();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//重置游戏</span></span><br><span class="line">    Game.prototype.resetGame = function () &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.food = new Food();</span><br><span class="line">        <span class="keyword">this</span>.snake = new Snake();</span><br><span class="line">        <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">        <span class="keyword">this</span>.bindKey();</span><br><span class="line">        <span class="keyword">this</span>.time(ctx);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    w.Game = Game;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> game = <span class="keyword">new</span> Game();</span><br><span class="line">  game.startGame(ctx);</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.reset&quot;</span>);</span><br><span class="line">  button.onclick = function () &#123;</span><br><span class="line">    game.resetGame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pause = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.pause&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> sr = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.src&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> inp = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.inp&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  pause.onclick = function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      game.time(ctx, inp.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      game.pausee();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>源代码地址：<a href="https://github.com/yq6668/code">https://github.com/yq6668/code</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>date格式化</title>
    <url>/2021/06/08/date%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-格式化日期对象"><a href="#1-格式化日期对象" class="headerlink" title="1. 格式化日期对象"></a>1. 格式化日期对象</h2><p>格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果date不是日期对象，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> year = d.getFullYear(),</span><br><span class="line">      month = d.getMonth() + <span class="number">1</span>, </span><br><span class="line">      date = d.getDate(), </span><br><span class="line">      hour = d.getHours(), </span><br><span class="line">      minute = d.getMinutes(), </span><br><span class="line">      second = d.getSeconds();</span><br><span class="line">  month = month &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + month : month;</span><br><span class="line">  date = date &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date : date;</span><br><span class="line">  hour = hour &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + hour : hour;</span><br><span class="line">  minute = minute &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + minute:minute;</span><br><span class="line">  second = second &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + second:second;</span><br><span class="line">  <span class="keyword">return</span> year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + date + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + minute + <span class="string">&#x27;:&#x27;</span> + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>计算时间差，返回相差的天/时/分/秒</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用求两个日期时间的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSpaceBetweenDate</span>(<span class="params">date1,date2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.得到两个日期之间的秒数</span></span><br><span class="line">    <span class="keyword">var</span> between = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.abs(date1 - date2)/<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//2.把秒数转换成相差多少天  多少小时  多少分钟  多少秒</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="built_in">Math</span>.floor(between/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">    <span class="keyword">var</span> hour =  <span class="built_in">Math</span>.floor(between/<span class="number">60</span>/<span class="number">60</span>) % <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">var</span> minute = <span class="built_in">Math</span>.floor(between/<span class="number">60</span>)%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">var</span> second = between%<span class="number">60</span>;</span><br><span class="line">    <span class="comment">//3.包装一个对象返回</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">day</span>:day,</span><br><span class="line">        <span class="attr">hour</span>:hour,</span><br><span class="line">        <span class="attr">minute</span>:minute,</span><br><span class="line">        <span class="attr">second</span>:second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-8-8 22:23:23&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-10-8 23:30:30&quot;</span>);</span><br><span class="line"><span class="comment">//使用自己写的方法求两个时间的差</span></span><br><span class="line"><span class="keyword">var</span> o = getSpaceBetweenDate(date1,date2);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch-cookie</title>
    <url>/2021/07/23/fetch-cookie/</url>
    <content><![CDATA[<h2 id="fetch发送请求携带cookie"><a href="#fetch发送请求携带cookie" class="headerlink" title="fetch发送请求携带cookie"></a>fetch发送请求携带cookie</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const result = fetch(url, &#123;</span><br><span class="line">        <span class="regexp">//</span>fetch不管在同域还是在跨域的情况下，默认都不携带cookie的，所以那些需要权限验证的请求就         无法正常获取到数据，这时候需要配置credentials项，有一下三个选项可添：</span><br><span class="line">        <span class="regexp">//</span>credentials:omit        默认值，忽略cookie的发送</span><br><span class="line">        <span class="regexp">//</span>credentials:same-origin 同源情况会发送cookie</span><br><span class="line">        <span class="regexp">//</span>credentials:include     表示既可以同域发送，也可以跨域发送</span><br><span class="line">        credentials: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js类型判断</title>
    <url>/2021/06/15/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="1-js类型判断"><a href="#1-js类型判断" class="headerlink" title="1. js类型判断"></a>1. js类型判断</h2><h3 id="1-1-js中的数据类型"><a href="#1-1-js中的数据类型" class="headerlink" title="1.1 js中的数据类型"></a>1.1 js中的数据类型</h3><p>基本数据类型：Undefined、Null、Boolean、Number、String，Symbol</p>
<p>引用数据类型 ：Object</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span>  und= <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nul = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)&#125;;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="1-2-typeof"><a href="#1-2-typeof" class="headerlink" title="1.2 typeof"></a>1.2 typeof</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool); <span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> und);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> nul);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1); <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure>

<p>typeof可以识别出基本类型boolean,number,undefined,string,symbol，但是不能识别null。不能识别引用数据类型，会把null、array、object统一归为object类型,但是可以识别出function。<br> 所以typeof可以用来识别一些基本类型。</p>
<h3 id="1-3-instanceof"><a href="#1-3-instanceof" class="headerlink" title="1.3 instanceof"></a>1.3 instanceof</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(und <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(nul <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fun <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>从结果中看出instanceof不能识别出基本的数据类型 number、boolean、string、undefined、unll、symbol。</p>
<p>但是可以检测出引用类型，如array、object、function，同时对于是使用new声明的类型，它还可以检测出多层继承关系。</p>
<p>其实也很好理解，js的继承都是采用原型链来继承的。比如objA instanceof A ，其实就是看objA的原型链上是否有A的原型，而A的原型上保留A的constructor属性。<br>所以instanceof一般用来检测对象类型，以及继承关系。</p>
<h3 id="1-4-constructor"><a href="#1-4-constructor" class="headerlink" title="1.4 constructor"></a>1.4 constructor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(bool.constructor === Boolean);// true</span><br><span class="line">console.log(num.constructor === Number);// true</span><br><span class="line">console.log(str.constructor === String);// true</span><br><span class="line">console.log(arr.constructor === Array);// true</span><br><span class="line">console.log(obj.constructor === Object);// true</span><br><span class="line">console.log(fun.constructor === Function);// true</span><br><span class="line">console.log(s1.constructor === Symbol);//true</span><br></pre></td></tr></table></figure>

<p>null、undefined没有construstor方法，因此constructor不能判断undefined和null。<br> 但是他是不安全的，因为contructor的指向是可以被改变。</p>
<h3 id="1-5-Object-prototype-toString-call"><a href="#1-5-Object-prototype-toString-call" class="headerlink" title="1.5 Object.prototype.toString.call"></a>1.5 Object.prototype.toString.call</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(bool));<span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(num));<span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str));<span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(und));<span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(nul));<span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr));<span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(fun));<span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(s1)); <span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>此方法可以相对较全的判断js的数据类型。</p>
<p>至于在项目中使用哪个判断，还是要看使用场景，具体的选择，一般基本的类型可以选择typeof，引用类型可以使用instanceof。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb导入导出</title>
    <url>/2021/06/22/mongodb%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h2 id="1-MongoDB的导入导出"><a href="#1-MongoDB的导入导出" class="headerlink" title="1.MongoDB的导入导出"></a>1.MongoDB的导入导出</h2><h3 id="1-1-MongoDB的导出功能"><a href="#1-1-MongoDB的导出功能" class="headerlink" title="1.1 MongoDB的导出功能"></a>1.1 MongoDB的导出功能</h3><h4 id="1-1-1-导出单个文件"><a href="#1-1-1-导出单个文件" class="headerlink" title="1.1.1 导出单个文件"></a>1.1.1 导出单个文件</h4><p>mongodb提供了导入和导出的功能，分别是MongoDB下载目录下的mongoexport.exe和mongoimport.exe文件 ，具体的导出命令格式如下：　　　　</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mongoexport -h dbhost -d dbname -c collectionName -o output</span></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<p>-h 数据库地址 </p>
<p>-d 指明使用的库</p>
<p>-c 指明要导出的集合</p>
<p>-o 指明要导出的文件名   文件支持多种格式，如txt,wps,xls等</p>
<p>具体示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.txt</span><br><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.wps</span><br><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.xls</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="1-1-2-导出整个集合"><a href="#1-1-2-导出整个集合" class="headerlink" title="1.1.2 导出整个集合"></a>1.1.2 导出整个集合</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mongodump</span> -h localhost:<span class="number">27017</span> -d xx -o D:\test\</span><br></pre></td></tr></table></figure>



<h3 id="1-2-MongoDB的导入功能"><a href="#1-2-MongoDB的导入功能" class="headerlink" title="1.2 MongoDB的导入功能"></a>1.2 MongoDB的导入功能</h3><p>导入数据可以使用命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mongoimport -h dbhost -d dbname -c collectionname <span class="selector-tag">input</span></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<p>-h 数据库地址</p>
<p>-d 指明使用的库</p>
<p>-c 指明要导入的集合   mongodb本身支持隐式创建，故事先无需创建集合</p>
<p>input 文件的地址</p>
<p>具体示例：　</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.txt</span><br><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.wps</span><br><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.xls</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2021/10/15/ws/</url>
    <content><![CDATA[<h1 id="1-websocket介绍"><a href="#1-websocket介绍" class="headerlink" title="1.websocket介绍"></a>1.websocket介绍</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于 服务器推送技术 的一种。</p>
<ul>
<li><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>
</li>
<li><p>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
</li>
<li><p>基于TCP的全双工通信协议</p>
<span id="more"></span></li>
</ul>
<h2 id="1-2-传统的实时通讯方式"><a href="#1-2-传统的实时通讯方式" class="headerlink" title="1.2.传统的实时通讯方式"></a>1.2.传统的实时通讯方式</h2><h3 id="1-2-1-Ajax轮询"><a href="#1-2-1-Ajax轮询" class="headerlink" title="1.2.1.Ajax轮询"></a>1.2.1.Ajax轮询</h3><p>ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p>
<h3 id="1-2-2-long-poll"><a href="#1-2-2-long-poll" class="headerlink" title="1.2.2.long poll"></a>1.2.2.long poll</h3><p>long poll其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p>
<p>总结：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ajax轮询 需要服务器有很快的处理速度和资源。（速度）</span><br><span class="line">long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</span><br><span class="line"></span><br><span class="line">长连接</span><br><span class="line">在页面里嵌入一个隐蔵<span class="selector-tag">iframe</span>，将这个隐蔵<span class="selector-tag">iframe</span>的<span class="attribute">src</span>属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。</span><br><span class="line">优点：消息即时到达，不发无用请求；管理起来也相对方便。</span><br><span class="line">缺点：服务器维护一个长连接会增加开销，当客户端越来越多的时候，server压力大</span><br><span class="line">实例：Gmail聊天</span><br></pre></td></tr></table></figure>



<h2 id="1-3-和http协议的关系"><a href="#1-3-和http协议的关系" class="headerlink" title="1.3.和http协议的关系"></a>1.3.和http协议的关系</h2><ul>
<li>Websocket是跟HTTP平级的OSI Layer7的协议，绝非基于HTTP，只不过为了兼容互联网现状采用了相同的端口，并利用HTTP消息切入Websocket协议。</li>
<li>Websocket是在TCP上独立设计的全双工，有message概念的通信协议，与HTTP没有任何必然联系。</li>
<li>WebSocket是HTML5出的协议，也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</li>
<li>Websocket其实是为了兼容现有浏览器的握手规范，也就是说它是HTTP协议上的一种补充</li>
</ul>
<p><img src="ws%5Cwe-http.png"></p>
<h2 id="1-4-scoket和webscoket"><a href="#1-4-scoket和webscoket" class="headerlink" title="1.4.scoket和webscoket"></a>1.4.scoket和webscoket</h2><h3 id="1-4-1-什么是socket"><a href="#1-4-1-什么是socket" class="headerlink" title="1.4.1.什么是socket"></a>1.4.1.什么是socket</h3><p> 在网络中的两个应用程序（进程）需要全双工相互通信（全双工即双方可同时向对方发送消息），需要用到的就是socket，它能够提供端对端通信，对于程序员来讲，他只需要在某个应用程序的一端（暂且称之为客户端）创建一个socket实例并且提供它所要连接一端（暂且称之为服务端）的IP地址和端口，而另外一端（服务端）创建另一个socket并绑定本地端口进行监听，然后客户端进行连接服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可 以双向通讯了，而且一旦建立这个连接之后，通信双方就没有客户端服务端之分了，提供的就是端对端通信了。我们可以采取这种方式构建一个桌面版的im程序，让不同主机上的用户发送消息。从本质上来说，socket并不是一个新的协议，它只是为了便于程序员进行网络编程而对tcp/ip协议族通信机制的一种封装。</p>
<h3 id="1-4-2-什么是websocket"><a href="#1-4-2-什么是websocket" class="headerlink" title="1.4.2.什么是websocket"></a>1.4.2.什么是websocket</h3><p>websocket是html5规范中的一个部分，它借鉴了socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制。同时，它又是一种新的应用层协议，websocket协议是为了提供web应用程序和服务端全双工通信而专门制定的一种应用层协议，通常它表示为：ws://echo.websocket.org/?encoding=text HTTP/1.1，可以看到除了前面的协议名和http不同之外，它的表示地址就是传统的url地址。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">websocket具有以下几个方面的优势：</span><br><span class="line">（<span class="number">1</span>）建立在 TCP 协议之上，服务器端的实现比较容易。</span><br><span class="line">（<span class="number">2</span>）与 HTTP 协议有着良好的兼容性。默认端口也是<span class="number">80</span>和<span class="number">443</span>，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</span><br><span class="line">（<span class="number">3</span>）数据格式比较轻量，性能开销小，通信高效。</span><br><span class="line">（<span class="number">4</span>）可以发送文本，也可以发送二进制数据。</span><br><span class="line">（<span class="number">5</span>）没有同源限制，客户端可以与任意服务器通信。</span><br><span class="line">（<span class="number">6</span>）协议标识符是ws（如果加密，则为wss），服务器网址就是 <span class="built_in">URL</span>。</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><img src="/2021/10/15/ws/xx.jpg"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。</span><br><span class="line"></span><br><span class="line"><span class="symbol">Socket</span> 其实并不是一个协议，是应用层与 TCP/<span class="built_in">IP</span> 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 <span class="built_in">IP</span> 协议，<span class="built_in">IP</span> 协议的连接则依赖于链路层等更低层次。</span><br><span class="line"></span><br><span class="line"><span class="symbol">WebSocket</span> 则是一个典型的应用层协议。</span><br><span class="line"></span><br><span class="line">总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。</span><br></pre></td></tr></table></figure>



<h2 id="1-5-webscoket的通信原理和机制"><a href="#1-5-webscoket的通信原理和机制" class="headerlink" title="1.5.webscoket的通信原理和机制"></a>1.5.webscoket的通信原理和机制</h2><p>正常http的get请求：</p>
<p><img src="/2021/10/15/ws/requrie.png"></p>
<h3 id="1-5-1-客户端：申请协议升级"><a href="#1-5-1-客户端：申请协议升级" class="headerlink" title="1.5.1.客户端：申请协议升级"></a>1.5.1.客户端：申请协议升级</h3><p>WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://127.0.0.1:3000</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">重点请求首部意义如下：</span><br><span class="line"></span><br><span class="line"><span class="symbol">Connection:</span> Upgrade：表示要升级协议</span><br><span class="line"><span class="symbol">Upgrade:</span> websocket：表示要升级到websocket协议。</span><br><span class="line"><span class="keyword">Sec</span>-WebSocket-Version: <span class="number">13</span>：表示websocket的版本。如果服务端不支持该版本，需要返回一个<span class="keyword">Sec</span>-WebSocket-Versionheader，里面包含服务端支持的版本号。</span><br><span class="line"><span class="keyword">Sec</span>-WebSocket-Key：与后面服务端响应首部的<span class="keyword">Sec</span>-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-服务端：响应协议升级"><a href="#1-5-2-服务端：响应协议升级" class="headerlink" title="1.5.2.服务端：响应协议升级"></a>1.5.2.服务端：响应协议升级</h3><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span>:Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Sec</span>-WebSocket-Accept: Oy<span class="number">4</span>NRAQ<span class="number">13</span>jhfONC<span class="number">7</span>bP<span class="number">8</span>dTKb<span class="number">4</span>PTU=</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Sec</span>-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</span><br><span class="line"><span class="attribute">toBase64</span>( sha<span class="number">1</span>( Sec-WebSocket-Key + <span class="number">258</span>EAFA<span class="number">5</span>-E<span class="number">914</span>-<span class="number">47</span>DA-<span class="number">95</span>CA-C<span class="number">5</span>AB<span class="number">0</span>DC<span class="number">85</span>B<span class="number">11</span> )  )</span><br></pre></td></tr></table></figure>

<h1 id="2-websocket的简单使用"><a href="#2-websocket的简单使用" class="headerlink" title="2.websocket的简单使用"></a>2.websocket的简单使用</h1><h2 id="2-1-websocket的创建"><a href="#2-1-websocket的创建" class="headerlink" title="2.1.websocket的创建"></a>2.1.websocket的创建</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">以下 API 用于创建 WebSocket 对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>, [protocol] );</span><br><span class="line">以上代码中的第一个参数 <span class="built_in">url</span>, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</span><br><span class="line"></span><br><span class="line">websocket 可以跟 HTTP 协议共用一个端口，它协议的前缀是 <span class="attribute">ws</span>:<span class="comment">//，如果是 HTTPS，那么就是 wss://，    webSocket 没有同源限制，客户端可以发送任意请求到服务端，只要目标服务器允许。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-websocket的属性和方法"><a href="#2-2-websocket的属性和方法" class="headerlink" title="2.2.websocket的属性和方法"></a>2.2.websocket的属性和方法</h2><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Socket.readyState</td>
<td align="left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td align="left">Socket.bufferedAmount</td>
<td align="left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody></table>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CONNECTING</span>：值为<span class="number">0</span>，表示正在连接。</span><br><span class="line"></span><br><span class="line"><span class="attribute">OPEN</span>：值为<span class="number">1</span>，表示连接成功，可以通信了。</span><br><span class="line"></span><br><span class="line"><span class="attribute">CLOSING</span>：值为<span class="number">2</span>，表示连接正在关闭。</span><br><span class="line"></span><br><span class="line"><span class="attribute">CLOSED</span>：值为<span class="number">3</span>，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>



<p>以下是 WebSocket 对象的相关事件。</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">事件处理程序</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">open</td>
<td align="left">Socket.onopen</td>
<td align="left">连接建立时触发</td>
</tr>
<tr>
<td align="left">message</td>
<td align="left">Socket.onmessage</td>
<td align="left">客户端接收服务端数据时触发</td>
</tr>
<tr>
<td align="left">error</td>
<td align="left">Socket.onerror</td>
<td align="left">通信发生错误时触发</td>
</tr>
<tr>
<td align="left">close</td>
<td align="left">Socket.onclose</td>
<td align="left">连接关闭时触发</td>
</tr>
</tbody></table>
<p>以下是 WebSocket 对象的相关方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<p><strong>websocket的使用</strong></p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ws.readyState == ws.CONNECTING) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接正在打开&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.send(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="comment">//可以看到 &quot;连接正在打开&quot;并没有被打印，说明open对应的就是OPEN状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.CONNECTING) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接正在打开1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.OPEN) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接已打开&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到消息后触发</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.send(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭时触发</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.CLOSED) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接已关闭&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接错误时触发</span></span><br><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.close();</span><br></pre></td></tr></table></figure>

<h2 id="2-3-node-js使用ws模块的WebSocket服务"><a href="#2-3-node-js使用ws模块的WebSocket服务" class="headerlink" title="2.3.node.js使用ws模块的WebSocket服务"></a>2.3.node.js使用ws模块的WebSocket服务</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">安装<span class="keyword">ws</span>模块</span><br><span class="line">npm install <span class="keyword">ws</span> --save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> WebSocketServer = WebSocket.Server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 websocket 服务器 监听在 3000 端口</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">3000</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器被客户端连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 ws 对象，就可以获取到客户端发送过来的信息和主动推送信息给客户端</span></span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">&#x27;massage&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//msg是我们从客户端受到的消息</span></span><br><span class="line">        ws.send(msg, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-事件监听"><a href="#2-3-1-事件监听" class="headerlink" title="2.3.1.事件监听"></a>2.3.1.事件监听</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">一般语法：.<span class="keyword">on</span>(“<span class="keyword">event</span>”, funcion)</span><br><span class="line">这是ws服务器的事件监听</span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">connection事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="params">(socket, request)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当握手完成后会发出，socket参数为WebSocket类型，request为http.IncomingMessage类型</span><br><span class="line">一般在这个事件中通过socket.<span class="literal">on</span>注册socket的事件</span><br><span class="line"></span><br><span class="line">error事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">(error)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当依赖的httpServer出现错误时发出，error为<span class="built_in">Error</span>类型</span><br><span class="line"></span><br><span class="line">headers事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;headers&quot;</span>, <span class="function"><span class="params">(headers, request)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">握手事件中，服务器即将响应请求时会发出这个事件，可以在方法中对headers进行修改</span><br><span class="line">headers为数组类型，request为http.IncomingMessage类型</span><br><span class="line"></span><br><span class="line">listening事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;listening&quot;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当绑定依赖的httoServer时发出</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-实例的监听事件"><a href="#2-3-2-实例的监听事件" class="headerlink" title="2.3.2.实例的监听事件"></a>2.3.2.实例的监听事件</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">一般语法： websocket.<span class="keyword">on</span>(“event”, <span class="function"><span class="keyword">Function</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function">无论是客户端还是服务端的实例都需要监听事件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">message 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当收到消息时发出，data 类型为 <span class="built_in">String</span>|Buffer|<span class="built_in">ArrayBuffer</span>|Buffer[]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">JavaScript 语言没有读取或操作二进制数据流的机制。</span><br><span class="line">Node.js 中引入了 Buffer 类型使我们可以操作 TCP流 或 文件流。</span><br><span class="line">Buffer 类型的对象类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。（ buf.length 是固定的，不允许修改 ）</span><br><span class="line">Buffer 是全局的，所以使用的时候无需 <span class="built_in">require</span>() 的方式来加载</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">close 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="params">(code, reason)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当连接断开时发出</span><br><span class="line"></span><br><span class="line">error 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">(error)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">open 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;open&quot;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">连接建立成功时发出</span><br><span class="line"></span><br><span class="line">ping 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;ping&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">收到ping消息时发出，data为Buffer类型</span><br><span class="line"></span><br><span class="line">pong 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;pong&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">收到pong消息时发出，data为Buffer类型</span><br><span class="line"></span><br><span class="line">注：ping，pong事件通常用来检测连接是否仍联通，由客户端(服务端)发出一个ping事件，服务端（客户端）收到后回复一个pong事件，客户端（服务端）收到后就知道连接仍然联通</span><br><span class="line"></span><br><span class="line">unexpected-response 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;unexpected-response&quot;</span>, <span class="function"><span class="params">(request, response)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">request &#123;http.ClientRequest&#125; response &#123;http.IncomingMessage&#125;</span><br><span class="line">当服务端返回的报文不是期待的结果，例如<span class="number">401</span>，则会发出这个事件，如果这个事件没有被监听，则会抛出一个错误</span><br><span class="line"></span><br><span class="line">upgrade事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;upgrade&quot;</span>, <span class="function"><span class="params">(response)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">response &#123;http.IncomingMessage&#125;</span><br><span class="line">握手过程中，当收到服务端回复时发出该事件，你可以在response中查看cookie等header</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>websocket</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>react-router url转换</title>
    <url>/2021/10/14/react-router%E4%BC%A0%E5%80%BC%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url链接： ?id=<span class="number">222</span>&amp;name=xxx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> location = useLocation()</span><br><span class="line"><span class="keyword">const</span> &#123; search &#125; = location</span><br><span class="line"><span class="keyword">const</span> paramsString = search.substring(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> searchParams = <span class="keyword">new</span> URLSearchParams(paramsString)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> token = searchParams.get(<span class="string">&#x27;id&#x27;</span>)   <span class="comment">// 222</span></span><br><span class="line"><span class="keyword">const</span> deviceId = searchParams.get(<span class="string">&#x27;name&#x27;</span>) <span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React-Router</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的this指向</title>
    <url>/2021/07/06/js%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="1-默认this绑定window"><a href="#1-默认this绑定window" class="headerlink" title="1. 默认this绑定window"></a>1. 默认this绑定window</h2><p>当在全局的上下文中调用this，此时this指向是默认的window。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name = <span class="string">&#x27;哈哈&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)  <span class="comment">//这里的this 处于全局上下文 指向的便是window</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name) <span class="comment">// 此时this.name 相当于window.name, 即全局作用域下的name ‘哈哈’</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-隐式绑定this"><a href="#2-隐式绑定this" class="headerlink" title="2. 隐式绑定this"></a>2. 隐式绑定this</h2><p>隐式绑定是指，谁调用就指向谁！<br>（其实与第一种默认绑定原理相同，第一种就是在window对象中调用的this）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> name = <span class="string">&#x27;哈哈&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>:<span class="string">&quot;嘿嘿&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)  <span class="comment">// 此时的this便是obj ， 因此输出是嘿嘿</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        obj.getName()  </span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：<br>如果再getName中再加一个函数，test（）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> name = <span class="string">&#x27;哈哈&#x27;</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> obj = &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">name</span>:<span class="string">&quot;嘿嘿&quot;</span>,</span></span><br><span class="line"><span class="javascript">            <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//打印嘿嘿</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">                <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)      </span></span><br><span class="line"><span class="javascript">                &#125;</span></span><br><span class="line"><span class="javascript">                test()<span class="comment">//没用指明谁调用，默认为window  打印哈哈</span></span></span><br><span class="line"><span class="javascript">            &#125;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        obj.getName()</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另外补充几个特例：</p>
<pre><code>&lt;script&gt;
    // 一些api可以指定this指向
    var obj2 = &#123;name:&quot;嘻嘻&quot;&#125;
    var arr=[1,2,12]
    // 对于arr.forEach 函数 ，当不传第二个参数时，默认this指向window
    arr.forEach(function(item,index,arr)&#123;
        console.log(this)
    &#125;)
    // 当有第二个参数时，指向指定的obj2
    arr.forEach(function(item,index,arr)&#123;
        console.log(this)
    &#125;,obj2)
    // sort 也是指向window
    arr.sort(function()&#123;
        console.log(this)
    &#125;)
&lt;/script&gt;
</code></pre>
<h2 id="3-显式绑定-call、apply、bind"><a href="#3-显式绑定-call、apply、bind" class="headerlink" title="3. 显式绑定 call、apply、bind"></a>3. 显式绑定 call、apply、bind</h2><p>三者都是用来显式指定this的指向，主要区别在于传参方式不同</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="string">&#x27;88888&#x27;</span>)</span><br><span class="line">    <span class="selector-tag">var</span> obj3 = &#123;</span><br><span class="line">    name:<span class="string">&#x27;吼吼&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    function f3(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)&#123;</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="selector-tag">a</span>,<span class="selector-tag">b</span>,c)</span><br><span class="line">    console<span class="selector-class">.log</span>(<span class="string">&quot;我的this是&quot;</span>,this)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f3(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)<span class="comment">//window 1,2,3</span></span><br><span class="line"></span><br><span class="line">    f3<span class="selector-class">.call</span>(obj3,<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;call&quot;</span>)<span class="comment">//obj3  4,5,&quot;call&quot;</span></span><br><span class="line">    f3<span class="selector-class">.apply</span>(obj3,<span class="selector-attr">[4,5,<span class="string">&quot;apply&quot;</span>]</span>)<span class="comment">//obj3 4,5,&quot;apply&quot;</span></span><br><span class="line">    f3<span class="selector-class">.bind</span>(obj3)(<span class="number">4</span>,<span class="number">5</span>,<span class="string">&quot;bind&quot;</span>)  <span class="comment">// bind特殊点是，其返回的是个函数  obj3 4,5,&quot;bind&quot;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>注：当指定的对象不存在时，this仍指向默认的window<br>比如：call(undefind)</p>
<h2 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h2><p>指使用构造函数创建对象时，this指向新创建的对象<br>var obj = new foo() 这时this指向新创建的对象obj</p>
<h2 id="5-优先级-new-gt-显式-gt-隐式-gt-默认"><a href="#5-优先级-new-gt-显式-gt-隐式-gt-默认" class="headerlink" title="5.优先级 new&gt;显式&gt;隐式&gt;默认"></a>5.优先级 new&gt;显式&gt;隐式&gt;默认</h2><h2 id="6-箭头函数"><a href="#6-箭头函数" class="headerlink" title="6. 箭头函数"></a>6. 箭头函数</h2><p>箭头函数是ES6新增的创建函数方法。但箭头函数和普通函数不同，箭头函数内部是没有this的指向的，箭头函数中的this实际上是向外层一级一级的查找作用域中的this（直到this有定义）<br>看代码比较好理解：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;箭头函数&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)   <span class="comment">// 因被obj4调用，所以this指的是obj4</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)   <span class="comment">// 上面以及分析过了，此处指的是 window</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> test = <span class="function">()=&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)   <span class="comment">// 但是这里的this 指向的仍是 obj4 与父级作用域的this是相同的</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    test()</span></span><br><span class="line"><span class="javascript">    test2()</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> obj4 = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">a</span>:<span class="string">&quot;哦哦&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">foo</span>:foo</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    obj4.foo()</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack内存溢出</title>
    <url>/2021/11/22/vue%E6%8F%90%E7%A4%BAmax-old/</url>
    <content><![CDATA[<h2 id="vue运行提示node-–max-old-space-size-10240"><a href="#vue运行提示node-–max-old-space-size-10240" class="headerlink" title="vue运行提示node –max-old-space-size=10240"></a>vue运行提示node –max-old-space-size=10240</h2><p>如果在运行项目的过程中出现这个问题，意思是内存溢出，因为在Node 中通过 JavaScript 使用内存时只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），当我们的项目如果非常的庞大，webpack 编译时就会占用很多的系统资源，就会造成内存溢出。</p>
<span id="more"></span>

<p>解决方法:</p>
<p>1.我们全局安装 increase-memory-limit:</p>
 <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g increase-memory-limit</span><br></pre></td></tr></table></figure>

<p>2.进入工程目录，执行如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">increase-memory-limit</span></span><br></pre></td></tr></table></figure>

<p>接下来重新运行我们的项目，一般就不会再次报错。</p>
<p> 如果出现了新的报错，例如：                                                                                                                             </p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;node--max-old-space-size=10240&quot;</span> 不是内部或外部命令，也不是可运行的程序</span><br></pre></td></tr></table></figure>

<p>解决方法如下：                                                                                                                                                          </p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">在 node_modules 文件夹搜索 <span class="string">&quot;%_prog%&quot;</span> 替换成 <span class="variable">%_prog%</span> (即去掉双引号)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>react如何渲染富文本内容</title>
    <url>/2021/12/16/react%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E5%AF%8C%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="react如何渲染富文本内容"><a href="#react如何渲染富文本内容" class="headerlink" title="react如何渲染富文本内容"></a>react如何渲染富文本内容</h2><p>在react中，通过富文本编辑器进行操作后的内容，会保留原有的标签样式，并不能正确展示。</p>
<p>方法如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">React</span>, &#123; <span class="type">Component</span> &#125; from <span class="symbol">&#x27;reac</span>t&#x27;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.state=&#123;</span><br><span class="line">      article:<span class="string">&quot;&lt;div&gt;我是富文本内容&lt;/div&gt;&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div dangerouslySetInnerHTML=&#123;&#123;__html:<span class="keyword">this</span>.state.article&#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">export <span class="keyword">default</span> <span class="type">App</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore不起作用</title>
    <url>/2021/09/17/gitignore%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h2 id="gitignore不起作用"><a href="#gitignore不起作用" class="headerlink" title=".gitignore不起作用"></a>.gitignore不起作用</h2><p>当我们使用git提交的时候，有时会发现”.gitignore”文件不起作用，但是里面的内容和格式都是正确的。</p>
<p>这是因为没有清除之前的缓存，导致不会再次执行修改后的”.gitignore”文件。</p>
<p>解决方法：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">清空git缓存</span><br><span class="line">git rm -r <span class="comment">--cached .</span></span><br><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git <span class="keyword">commit</span> -m <span class="string">&#x27;update .gitignore&#x27;</span></span><br></pre></td></tr></table></figure>

<p>问题解决。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ts声明全局变量</title>
    <url>/2022/01/17/ts%E5%A3%B0%E6%98%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="ts声明全局变量"><a href="#ts声明全局变量" class="headerlink" title="ts声明全局变量"></a>ts声明全局变量</h2><p>当我们把声明统一放在一个文件夹中的时候，每个页面要使用时都必须引入声明文件，非常的不方便。</p>
<p>这时我们可以使用命名空间来声明全局变量，这样就不需要引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//type.d.ts</span></span><br><span class="line">declare namespace TYPE &#123;</span><br><span class="line">    type students = &#123;</span><br><span class="line">        <span class="attr">id</span>: number,</span><br><span class="line">        <span class="attr">name</span>: string,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//index.ts</span></span><br><span class="line"><span class="comment">//import &#123;students&#125; from &quot;type.d.ts&quot; 现在不需要引入声明文件</span></span><br><span class="line"><span class="keyword">const</span> obj:TYPE.students=&#123;</span><br><span class="line">    <span class="attr">id</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;xx&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router的高级路由匹配</title>
    <url>/2021/10/16/vue-router%E7%9A%84%E9%AB%98%E7%BA%A7%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="Vue-Router-高级路由匹配"><a href="#Vue-Router-高级路由匹配" class="headerlink" title="Vue-Router 高级路由匹配"></a>Vue-Router 高级路由匹配</h2><p>1、基础常见的全路径匹配，必须是等于才匹配</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;path:<span class="string">&#x27;/&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>2、动态路径，”/params/foo/bar” 通过$route.params获取{ { foo: ‘foo’, bar: ‘bar’ } }</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;path:<span class="string">&#x27;/params/:foo/:bar&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>3、最后一位路径可有可无，”/optional-params”、”/optional-params/foo”，通过$route.params获取{ { foo: ‘foo’ } }</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;path:<span class="string">&#x27;/optional-params/:foo?&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>4、一个参数后面可以跟一个括号中的正则表达式模式，限制该位置路劲的值类型，只有当 :id 全部为数字时，才会匹配此路由，“/params-with-regex/123”，通过$route.params获取{ { id: ‘123’ } }</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&#123;path:&#x27;/params-<span class="keyword">with</span>-regex/:<span class="built_in">id</span>(\\d+)&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>5、星号可以匹配任何东西，”/asterisk/foo”、”/asterisk/abc”、”/asterisk/123”……</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;path:<span class="string">&#x27;/asterisk/*&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>6、通过用括号包裹并添加“？”来使路径的一部分成为可选的，”/optional-group/bar”、”/optional-group/foo/bar”</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;path:&#x27;/optional-group/(<span class="name">foo/</span>)?bar&#x27;&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>React Native打开系统浏览器</title>
    <url>/2021/11/24/React-Native%E6%89%93%E5%BC%80%E7%B3%BB%E7%BB%9F%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    <content><![CDATA[<h2 id="React-Native如何打开系统浏览器"><a href="#React-Native如何打开系统浏览器" class="headerlink" title="React Native如何打开系统浏览器"></a>React Native如何打开系统浏览器</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Linking</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用系统浏览器访问指定URL</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> contactBaidu = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> baiduURL = <span class="string">&#x27;http://www.baidu.com/&#x27;</span>         </span><br><span class="line">  </span><br><span class="line">  Linking.canOpenURL(baiduURL).then(<span class="function"><span class="params">supported</span> =&gt;</span> &#123;         </span><br><span class="line">      <span class="keyword">if</span> (!supported) &#123;            </span><br><span class="line">          <span class="built_in">console</span>.warn(<span class="string">&#x27;Can\&#x27;t handle url: &#x27;</span> + baiduURL);            </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">          <span class="keyword">return</span> Linking.openURL(baiduURL);            </span><br><span class="line">      &#125;            </span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(<span class="string">&#x27;An error occurred&#x27;</span>,baiduURL));            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的原型和原型链</title>
    <url>/2021/08/12/js%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="js中的原型和原型链"><a href="#js中的原型和原型链" class="headerlink" title="js中的原型和原型链"></a>js中的原型和原型链</h2><p><strong>原型关系</strong>：</p>
<ul>
<li>每个 class都有显示原型 prototype</li>
<li>每个实例都有隐式原型 _ proto_</li>
<li>实例的_ proto_指向对应 class 的 prototype</li>
</ul>
<p><strong>原型:</strong>  在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个<code>函数对象</code>都有一个<code>prototype</code> 属性，这个属性指向函数的<code>原型对象</code>。</p>
<p><strong>原型链</strong>：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针__proto__,该指针是指向上一层的原型对象，而上一层的原型对象的结构依然类似。因此可以利用__proto__一直指向Object的原型对象上，而Object原型对象用Object.prototype.__ proto__ = null表示原型链顶端。如此形成了js的原型链继承。同时所有的js对象都有Object的基本防范</p>
<p><strong>特点:</strong>  <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实现路由懒加载</title>
    <url>/2021/10/21/vue%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="1-路由懒加载"><a href="#1-路由懒加载" class="headerlink" title="1. 路由懒加载"></a>1. 路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将</span></span><br><span class="line"><span class="comment">// import UserDetails from &#x27;./views/UserDetails&#x27;</span></span><br><span class="line"><span class="comment">// 替换成</span></span><br><span class="line"><span class="keyword">const</span> UserDetails = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./views/UserDetails&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/users/:id&#x27;</span>, <span class="attr">component</span>: UserDetails &#125;],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-把组件按组分块"><a href="#2-把组件按组分块" class="headerlink" title="2. 把组件按组分块"></a>2. 把组件按组分块</h2><p>有时候我们想把某个路由下的所有组件都打包在同个异步块 (chunk) 中。只需要使用命名 chunk，一个特殊的注释语法来提供 chunk name (需要 Webpack &gt; 2.4)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> UserDetails = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-user&quot; */</span> <span class="string">&#x27;./UserDetails.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UserDashboard = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-user&quot; */</span> <span class="string">&#x27;./UserDashboard.vue&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UserProfileEdit = <span class="function">() =&gt;</span></span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;group-user&quot; */</span> <span class="string">&#x27;./UserProfileEdit.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>webpack 会将任何一个异步模块与相同的块名称组合到相同的异步块中。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序缓存时效性问题</title>
    <url>/2021/06/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%93%E5%AD%98%E6%97%B6%E6%95%88%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="微信小程序缓存时效性问题"><a href="#微信小程序缓存时效性问题" class="headerlink" title="微信小程序缓存时效性问题"></a>微信小程序缓存时效性问题</h2><p>在微信小程序中如果我们通过：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">wx.<span class="keyword">set</span>Storage（wx.<span class="keyword">set</span>StorageSync）</span><br><span class="line">wx.getStorage（wx.getStorageSync）</span><br><span class="line">wx.<span class="keyword">clear</span>Storage（wx.<span class="keyword">clear</span>StorageSync）</span><br></pre></td></tr></table></figure>

<p>这些来设置缓存，那么这些都是永久性缓存，不会自动销毁。这时可以通过再设置一个时间缓存来进行判断。</p>
<p>代码如下：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置缓存，key是取出缓存时用到的名字，val是需要缓存的数据，time是需要存放的时间</span></span><br><span class="line"><span class="function"><span class="title">put</span>(<span class="params">key, val, time</span>)</span> &#123;</span><br><span class="line">   wx.setStorageSync(key, val)</span><br><span class="line">   <span class="keyword">var</span> seconds = <span class="built_in">parseInt</span>(time);</span><br><span class="line">   <span class="keyword">if</span> (seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">var</span> timestamp = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>());</span><br><span class="line">     timestamp = timestamp / <span class="number">1000</span> + seconds;</span><br><span class="line">     wx.setStorageSync(key + <span class="string">&#x27;dtime&#x27;</span>, timestamp + <span class="string">&quot;&quot;</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     wx.removeStorageSync(key + <span class="string">&#x27;dtime&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="comment">//获取缓存，key是之前设置缓存的名字，def是无缓存时返回的默认值，def可以为空</span></span><br><span class="line"> <span class="function"><span class="title">get</span>(<span class="params">key, def</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> deadtime = <span class="built_in">parseInt</span>(wx.getStorageSync(key + <span class="string">&#x27;dtime&#x27;</span>))</span><br><span class="line">   <span class="keyword">if</span> (deadtime) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">parseInt</span>(deadtime) &lt; <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) / <span class="number">1000</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (def) &#123; <span class="keyword">return</span> def; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> res = wx.getStorageSync(key);</span><br><span class="line">   <span class="keyword">if</span> (res) &#123;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> def;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>别忘了清除缓存时要清除两个，一个是本身，另一个是本身+“dtime”</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.removeStorageSync</span>(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.removeStorageSync</span>(<span class="string">&#x27;userdtime&#x27;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WX</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>wx</tag>
      </tags>
  </entry>
  <entry>
    <title>JS对象合并方法</title>
    <url>/2021/09/08/JS%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="JS对象合并方法"><a href="#JS对象合并方法" class="headerlink" title="JS对象合并方法"></a>JS对象合并方法</h2><p>这里主要讲的是es6的合并对象方法，更加的方便快捷。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;哈哈&#x27;</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;嘿嘿嘿&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj2=&#123;</span><br><span class="line">    <span class="attr">where</span>:<span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="function"><span class="title">do</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;I like JavaScript ！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：利用扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> obj3=&#123;...obj1,...obj2&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：利用ES6 Object新增assign方法</span></span><br><span class="line"><span class="keyword">let</span> obj4=<span class="built_in">Object</span>.assign(&#123;&#125;,obj1,obj2);</span><br><span class="line"><span class="built_in">console</span>.log(obj4);</span><br></pre></td></tr></table></figure>

<span id="more"></span>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JS正则匹配规则</title>
    <url>/2021/08/17/JS%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="1-JS正则匹配的基本规则"><a href="#1-JS正则匹配的基本规则" class="headerlink" title="1. JS正则匹配的基本规则"></a>1. JS正则匹配的基本规则</h2><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">\d   数字</span><br><span class="line">\w   字母(数字 字母 下划线)</span><br><span class="line">\s   空白字符</span><br><span class="line">\D   非数字</span><br><span class="line">\W   非字母</span><br><span class="line">\S   非空白</span><br><span class="line">.    通配符(匹配除了\n之外的所有字符)</span><br><span class="line">\b   单词边界匹配</span><br><span class="line"></span><br><span class="line"><span class="built_in">n</span>*    匹配<span class="number">0</span>个或多个<span class="built_in">n</span></span><br><span class="line"><span class="built_in">n</span>+    匹配至少<span class="number">1</span>个<span class="built_in">n</span></span><br><span class="line"><span class="built_in">n</span>?    匹配<span class="number">0</span>个或者<span class="number">1</span>个<span class="built_in">n</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">n</span>&#123;<span class="number">1</span>,&#125;    <span class="built_in">n</span>至少出现<span class="number">1</span>次</span><br><span class="line"><span class="built_in">n</span>&#123;<span class="number">1</span>,<span class="number">3</span>&#125;   <span class="built_in">n</span>出现<span class="number">1</span>到<span class="number">3</span>次</span><br><span class="line"><span class="built_in">n</span>&#123;<span class="number">1</span>&#125;     <span class="built_in">n</span>恰好出现<span class="number">1</span>次</span><br><span class="line"></span><br><span class="line">[abc]    取值在abc之间</span><br><span class="line">[^abc]   取值在非abc</span><br><span class="line">[a | b]  取值在a或者b之间</span><br><span class="line">[a-z]    取值在a到z之间</span><br><span class="line"></span><br><span class="line">i   忽略大小写匹配</span><br><span class="line">g   全局匹配</span><br><span class="line"></span><br><span class="line">^   表示开头</span><br><span class="line">$   表示结束</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="2-常用正则表达式"><a href="#2-常用正则表达式" class="headerlink" title="2. 常用正则表达式"></a>2. 常用正则表达式</h2><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">1</span>. 汉字：^[\u<span class="number">4</span>e<span class="number">00</span>-\u<span class="number">9</span>fa<span class="number">5</span>]&#123;<span class="number">0</span>,&#125;$</span><br><span class="line"></span><br><span class="line"><span class="attribute">2</span>. 英文和数字：^[A-Za-z<span class="number">0</span>-<span class="number">9</span>]+$ 或 ^[A-Za-z<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>,<span class="number">40</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="attribute">3</span>. 长度为<span class="number">3</span>-<span class="number">20</span>的所有字符：^.&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="attribute">4</span>. 由<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z]+$</span><br><span class="line"></span><br><span class="line"><span class="attribute">5</span>. 由<span class="number">26</span>个大写英文字母组成的字符串：^[A-Z]+$</span><br><span class="line"></span><br><span class="line"><span class="attribute">6</span>. 由<span class="number">26</span>个小写英文字母组成的字符串：^[a-z]+$</span><br><span class="line"></span><br><span class="line"><span class="attribute">7</span>. 由数字和<span class="number">26</span>个英文字母组成的字符串：^[A-Za-z<span class="number">0</span>-<span class="number">9</span>]+$</span><br><span class="line"></span><br><span class="line"><span class="attribute">8</span>. 由数字、<span class="number">26</span>个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;<span class="number">3</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="attribute">9</span>. 中文、英文、数字包括下划线：^[\u<span class="number">4</span>E<span class="number">00</span>-\u<span class="number">9</span>FA<span class="number">5</span>A-Za-z<span class="number">0</span>-<span class="number">9</span>_]+$</span><br><span class="line"></span><br><span class="line"><span class="attribute">10</span>. 中文、英文、数字但不包括下划线等符号：^[\u<span class="number">4</span>E<span class="number">00</span>-\u<span class="number">9</span>FA<span class="number">5</span>A-Za-z<span class="number">0</span>-<span class="number">9</span>]+$ 或 ^[\u<span class="number">4</span>E<span class="number">00</span>-\u<span class="number">9</span>FA<span class="number">5</span>A-Za-z<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">2</span>,<span class="number">20</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="attribute">11</span>. 可以输入含有^%&amp;&#x27;,;=?$\<span class="string">&quot;等字符：[^%&amp;&#x27;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML中清除浮动带来的影响</title>
    <url>/2021/02/06/HTML%E4%B8%AD%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h2 id="HTML中清除浮动带来的影响"><a href="#HTML中清除浮动带来的影响" class="headerlink" title="HTML中清除浮动带来的影响"></a>HTML中清除浮动带来的影响</h2><p>清除浮动带来的影响有两种方法：</p>
<p>1、利用clear属性</p>
<p>2、利用after伪类</p>
<p>代码如下：</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#header</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#body</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/*height: 300px;*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#left</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">280px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">15%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#4cae4c</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#center</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">280px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">70%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#3c763d</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">280px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#bottom</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#ffceb6</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/*清除浮动元素带来的影响*/</span></span></span><br><span class="line"><span class="css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css"></span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="comment">/*清除浮动的方式二：利用伪类after*/</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.clearfix</span>:after&#123;</span></span><br><span class="line"><span class="css">            content: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="css">            <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#foot</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">background-color</span>: <span class="number">#2e6da4</span>;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Float浮动<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左侧div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span>中间div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右侧div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;div id=&quot;bottom&quot;&gt;底部div&lt;/div&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>Css</tag>
      </tags>
  </entry>
</search>
