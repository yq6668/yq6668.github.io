<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BFC</title>
    <url>/2021/06/12/BFC/</url>
    <content><![CDATA[<h2 id="1-BFC-块级格式化上下文"><a href="#1-BFC-块级格式化上下文" class="headerlink" title="1.BFC(块级格式化上下文)"></a>1.BFC(块级格式化上下文)</h2><p>BFC(Block formatting context)</p>
<p>直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<span id="more"></span>

<h3 id="1-1-什么情况下可以让元素产生BFC"><a href="#1-1-什么情况下可以让元素产生BFC" class="headerlink" title="1.1 什么情况下可以让元素产生BFC"></a>1.1 什么情况下可以让元素产生BFC</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>根元素</span><br><span class="line"><span class="number">2.f</span>loat属性不为none</span><br><span class="line"><span class="number">3.</span>position为absolute或fixed</span><br><span class="line"><span class="number">4.</span>display为<span class="keyword">inline</span>-block, table-cell, table-caption, flex, <span class="keyword">inline</span>-flex</span><br><span class="line"><span class="number">5.</span>overflow不为visible。</span><br><span class="line"></span><br><span class="line">但其中，最常见的就是overflow:hidden、<span class="keyword">float</span>:left/right、position:absolute。也就是说每次看到这些属性的时候，就代表了该元素以及创建了一个BFC了。</span><br><span class="line"></span><br><span class="line">注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们暂且不研究。</span><br></pre></td></tr></table></figure>

<p>虽然添加上述的任意一条都能创建BFC，但会有一些副作用：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.display</span>: <span class="selector-tag">table</span> 可能引发响应性问题</span><br><span class="line"><span class="number">2</span><span class="selector-class">.overflow</span>: scroll 可能产生多余的滚动条</span><br><span class="line"><span class="number">3</span><span class="selector-class">.float</span>: <span class="attribute">left</span> 将把元素移至左侧，并被其他元素环绕</span><br><span class="line"><span class="number">4</span><span class="selector-class">.overflow</span>: hidden 将裁切溢出元素</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们一般通过overflow:hidden来开启BFC</p>
<h3 id="1-2-BFC元素所具有的特性"><a href="#1-2-BFC元素所具有的特性" class="headerlink" title="1.2 BFC元素所具有的特性"></a>1.2 BFC元素所具有的特性</h3><p>BFC布局规则特性：</p>
<p>1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.</p>
<p>2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>
<p>4.BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</p>
<p>5.计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</p>
<p>6.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</p>
<h3 id="1-3-BFC的主要用途"><a href="#1-3-BFC的主要用途" class="headerlink" title="1.3 BFC的主要用途"></a>1.3 BFC的主要用途</h3><p>BFC能用来做什么？</p>
<p>(1) 清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p>
<p>主要用到 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/12/BFC/BFC%5Cfu.jpg"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;par&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;child&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">        &lt;<span class="selector-tag">div</span> class=&quot;child&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="selector-class">.par</span> &#123;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fcc</span>;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#f66</span>;</span><br><span class="line">     <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>(2) 解决外边距合并问题</p>
<p>外边距合并的问题。</p>
<p>主要用到 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">盒子垂直方向的距离由<span class="attribute">margin</span>决定。属于同一个BFC的两个相邻盒子的<span class="attribute">margin</span>会发生重叠</span><br></pre></td></tr></table></figure>

<p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
<p><img src="/2021/06/12/BFC/BFC%5Cma.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">p</span>&gt;Haha&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;wrap&quot;&gt;</span><br><span class="line">        &lt;<span class="selector-tag">p</span>&gt;Hehe&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.wrap</span> &#123;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#f55</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">text-align</span>:center;</span><br><span class="line">        <span class="attribute">margin</span>: <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>(3) 制作右侧自适应的盒子问题</p>
<p>主要用到 </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</span><br></pre></td></tr></table></figure>

<p><img src="/2021/06/12/BFC/BFC%5Cyou.png"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">aside</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="selector-tag">main</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-class">.aside</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#f66</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="selector-class">.main</span> &#123;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#fcc</span>;</span><br><span class="line">        <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>(4) 消除子元素浮动对父元素的兄弟的文字布局产生的影响</p>
<p>​    当浮动的子元素的高度大于父亲的高度的时候，此时会对父亲后面的兄弟中文字布局产生影响，父亲后面兄弟中的文字会贴着浮动的子元素后面进行布局。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">   <span class="selector-class">.parent</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">width</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">height</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">background</span>:yellow;</span></span><br><span class="line"><span class="css">       <span class="attribute">overflow</span>:hidden;<span class="comment">/*开启BFC，彻底消除parent里面元素对外面布局产生的影响*/</span></span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css">   </span></span><br><span class="line"><span class="css">   <span class="selector-class">.parent</span> <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="css">       <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">       <span class="attribute">height</span>:<span class="number">350px</span>;</span></span><br><span class="line"><span class="css">   &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  	你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    你好啊<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-BFC-总结"><a href="#1-4-BFC-总结" class="headerlink" title="1.4 BFC 总结"></a>1.4 BFC 总结</h3><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等。</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas贪吃蛇</title>
    <url>/2021/09/23/canvas%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<img src="/2021/09/23/canvas%E8%B4%AA%E5%90%83%E8%9B%87/tc.png" style="zoom:67%;">

<span id="more"></span>

<h1 id="Food"><a href="#Food" class="headerlink" title="Food()"></a>Food()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//食物的自调用函数</span></span><br><span class="line">(function (w) &#123;</span><br><span class="line">    <span class="comment">//食物的构造函数</span></span><br><span class="line">    function Food(x, y, width, height) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.y = y || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.width = width || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.height = height || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.q = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//食物的初始化方法</span></span><br><span class="line">    <span class="keyword">var</span> image = new Image();</span><br><span class="line">    image.src = <span class="string">&quot;images/bianbian.png&quot;</span>;</span><br><span class="line">    Food.prototype.<span class="keyword">init</span> = function (ctx, x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.q = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定食物的坐标</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.q == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> maxX = Math.floor(ctx.canvas.width / <span class="keyword">this</span>.width);</span><br><span class="line">            <span class="keyword">var</span> maxY = Math.floor(ctx.canvas.height / <span class="keyword">this</span>.height);</span><br><span class="line">            x = Random.getRandom(<span class="number">0</span>, maxX);</span><br><span class="line">            y = Random.getRandom(<span class="number">0</span>, maxY);</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">            <span class="keyword">this</span>.q = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建页面元素</span></span><br><span class="line">        ctx.beginPath();</span><br><span class="line">        ctx.drawImage(image, <span class="keyword">this</span>.x * <span class="number">40</span>, <span class="keyword">this</span>.y * <span class="number">40</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">        <span class="comment">// ctx.fillStyle = this.color;</span></span><br><span class="line">        <span class="comment">// ctx.fillRect(this.x*40, this.y*40, this.width, this.height);</span></span><br><span class="line">    &#125;;</span><br><span class="line">    w.Food = Food;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="Snake"><a href="#Snake" class="headerlink" title="Snake()"></a>Snake()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//蛇的自调用函数</span></span><br><span class="line">(function (w) &#123;</span><br><span class="line">    <span class="keyword">var</span> sco = document.querySelector(<span class="string">&quot;.sco&quot;</span>);</span><br><span class="line">    <span class="comment">//小蛇的构造函数</span></span><br><span class="line">    function Snake(width, height, direction) &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.height = height || <span class="number">40</span>;</span><br><span class="line">        <span class="keyword">this</span>.direction = direction || <span class="string">&quot;right&quot;</span>;</span><br><span class="line">        <span class="comment">//游戏分数统计</span></span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        sco.innerText = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="comment">//小蛇身躯</span></span><br><span class="line">        <span class="keyword">this</span>.body = [</span><br><span class="line">            &#123; x: <span class="number">3</span>, y: <span class="number">2</span>, color: <span class="string">&quot;red&quot;</span> &#125;,</span><br><span class="line">            &#123; x: <span class="number">2</span>, y: <span class="number">2</span>, color: <span class="string">&quot;green&quot;</span> &#125;,</span><br><span class="line">            &#123; x: <span class="number">1</span>, y: <span class="number">2</span>, color: <span class="string">&quot;green&quot;</span> &#125;,</span><br><span class="line">            <span class="comment">// &#123; x: 3, y: 2, color: &quot;images/header.png&quot; &#125;,</span></span><br><span class="line">            <span class="comment">// &#123; x: 2, y: 2, color: &quot;images/body.png&quot; &#125;,</span></span><br><span class="line">            <span class="comment">// &#123; x: 1, y: 2, color: &quot;images/body.png&quot; &#125;,</span></span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//小蛇的初始化方法</span></span><br><span class="line"></span><br><span class="line">    Snake.prototype.<span class="keyword">init</span> = function (ctx) &#123;</span><br><span class="line">        <span class="comment">//创建小蛇的每一个身躯</span></span><br><span class="line">        <span class="keyword">var</span> image = new Image();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">            <span class="comment">//创建页面元素</span></span><br><span class="line">            <span class="comment">// image.src = this.body[i].color;</span></span><br><span class="line">            <span class="comment">// ctx.drawImage(image, this.body[i].x * 40, this.body[i].y * 40, this.width, this.height);</span></span><br><span class="line">            ctx.beginPath();</span><br><span class="line">            ctx.fillStyle = <span class="keyword">this</span>.body[i].color;</span><br><span class="line">            ctx.fillRect(<span class="keyword">this</span>.body[i].x * <span class="number">40</span>, <span class="keyword">this</span>.body[i].y * <span class="number">40</span>, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// image.src = this.body[0].color;</span></span><br><span class="line">        <span class="comment">// var that=this;</span></span><br><span class="line">        <span class="comment">// image.onload = function () &#123;</span></span><br><span class="line">        <span class="comment">//     console.log(that);</span></span><br><span class="line">        <span class="comment">//     for (var i = 0; i &lt; that.body.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//         if(i==0)&#123;</span></span><br><span class="line">        <span class="comment">//             console.log(i);</span></span><br><span class="line">        <span class="comment">//             ctx.drawImage(image, that.body[i].x * 40, that.body[i].y * 40, that.width, that.height);</span></span><br><span class="line">        <span class="comment">//         &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//             image.src = that.body[1].color;</span></span><br><span class="line">        <span class="comment">//             console.log(image);</span></span><br><span class="line">        <span class="comment">//             ctx.drawImage(image, that.body[i].x * 40, that.body[i].y * 40, that.width, that.height);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ctx.beginPath();</span></span><br><span class="line">        <span class="comment">// ctx.fillStyle = this.body[i].color;</span></span><br><span class="line">        <span class="comment">// ctx.fillRect(this.body[i].x * 40, this.body[i].y * 40, this.width, this.height);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//小蛇移动的方法</span></span><br><span class="line">    Snake.prototype.move = function (ctx, food) &#123;</span><br><span class="line">        <span class="comment">//改变非蛇头部分坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">this</span>.body.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">this</span>.body[i].x = <span class="keyword">this</span>.body[i - <span class="number">1</span>].x;</span><br><span class="line">            <span class="keyword">this</span>.body[i].y = <span class="keyword">this</span>.body[i - <span class="number">1</span>].y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//改变蛇头部分坐标</span></span><br><span class="line">        switch (<span class="keyword">this</span>.direction) &#123;</span><br><span class="line">            case <span class="string">&quot;right&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].x += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;left&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].x -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;up&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].y -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            case <span class="string">&quot;down&quot;</span>:</span><br><span class="line">                <span class="keyword">this</span>.body[<span class="number">0</span>].y += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当蛇头坐标和食物坐标重叠的时候，就可以吃食物了</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.body[<span class="number">0</span>].x === food.x &amp;&amp; <span class="keyword">this</span>.body[<span class="number">0</span>].y === food.y) &#123;</span><br><span class="line">            <span class="comment">//让小蛇的身躯+1</span></span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">500</span>;</span><br><span class="line">            sco.innerText = <span class="keyword">this</span>.score;</span><br><span class="line">            <span class="keyword">var</span> last = <span class="keyword">this</span>.body[<span class="keyword">this</span>.body.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">var</span> item = &#123;</span><br><span class="line">                x: last.x,</span><br><span class="line">                y: last.y,</span><br><span class="line">                color: last.color,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">this</span>.body.push(item);</span><br><span class="line">            food.<span class="keyword">init</span>(ctx, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.body.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.body[i].x === food.x &amp;&amp; <span class="keyword">this</span>.body[i].y === food.y) &#123;</span><br><span class="line">                food.<span class="keyword">init</span>(ctx, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每次移动就会删除之前的，重新生成</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">init</span>(ctx);</span><br><span class="line">    &#125;;</span><br><span class="line">    w.Snake = Snake;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="Game"><a href="#Game" class="headerlink" title="Game()"></a>Game()</h1><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(function (w) &#123;</span><br><span class="line">    function Game() &#123;</span><br><span class="line">        <span class="keyword">this</span>.food = new Food();</span><br><span class="line">        <span class="keyword">this</span>.snake = new Snake();</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开始游戏</span></span><br><span class="line">    Game.prototype.startGame = function (ctx) &#123;</span><br><span class="line">        <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">        <span class="keyword">this</span>.bindKey();</span><br><span class="line">        <span class="keyword">this</span>.time(ctx);</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Game.prototype.time = function (ctx,w) &#123;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">        i = w||<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">this</span>.timer = setInterval(() =&gt; &#123;</span><br><span class="line">            ctx.clearRect(<span class="number">0</span>, <span class="number">0</span>, ctx.canvas.width, ctx.canvas.height);</span><br><span class="line">            <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">            <span class="keyword">this</span>.snake.move(ctx, <span class="keyword">this</span>.food);</span><br><span class="line">            <span class="keyword">this</span>.gameOver(ctx);</span><br><span class="line">        &#125;, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂停游戏</span></span><br><span class="line">    Game.prototype.pausee = function () &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//绑定键盘的按键</span></span><br><span class="line">    Game.prototype.bindKey = function () &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        document.onkeydown = function (e) &#123;</span><br><span class="line">            <span class="keyword">var</span> e = e || window.event;</span><br><span class="line">            switch (e.keyCode) &#123;</span><br><span class="line">                <span class="comment">//上</span></span><br><span class="line">                case <span class="number">38</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;up&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;down&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;up&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//右</span></span><br><span class="line">                case <span class="number">39</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;right&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;left&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;right&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//下</span></span><br><span class="line">                case <span class="number">40</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;up&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;down&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;down&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//左</span></span><br><span class="line">                case <span class="number">37</span>:</span><br><span class="line">                    <span class="keyword">if</span> (</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;right&quot;</span> ||</span><br><span class="line">                        that.snake.direction === <span class="string">&quot;left&quot;</span></span><br><span class="line">                    ) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    that.snake.direction = <span class="string">&quot;left&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">3000</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> list=document.querySelectorAll(<span class="string">&quot;.aa&quot;</span>);</span><br><span class="line">    <span class="comment">//排行榜</span></span><br><span class="line">    Game.prototype.lists=function()&#123;</span><br><span class="line">        <span class="comment">//排行榜记录</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= <span class="keyword">this</span>.snake.score) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> x=arr.length-<span class="number">1</span>;x&gt;i;x--)&#123;</span><br><span class="line">                    arr[x]=arr[x-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[i] = <span class="keyword">this</span>.snake.score;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            list[j].innerText=arr[j];</span><br><span class="line">            console.log(list[j]);</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断游戏结束</span></span><br><span class="line">    Game.prototype.gameOver = function (ctx) &#123;</span><br><span class="line">        <span class="comment">//游戏结束的判定条件</span></span><br><span class="line">        <span class="comment">//1.蛇头超出地图边界</span></span><br><span class="line">        <span class="keyword">var</span> head = <span class="keyword">this</span>.snake.body[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> maxX = Math.floor(ctx.canvas.width / <span class="keyword">this</span>.food.width);</span><br><span class="line">        <span class="keyword">var</span> maxY = Math.floor(ctx.canvas.height / <span class="keyword">this</span>.food.height);</span><br><span class="line">        <span class="keyword">if</span> (head.x &lt; <span class="number">0</span> || head.y &lt; <span class="number">0</span> || head.x &gt;= maxX || head.y &gt;= maxY) &#123;</span><br><span class="line">            clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">            <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">this</span>.lists();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.蛇头撞到自己的身躯  遍历每一个身躯，看每一个身躯的坐标是否和蛇头重叠</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.snake.body.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> item = <span class="keyword">this</span>.snake.body[i];</span><br><span class="line">            <span class="comment">//头撞身躯了</span></span><br><span class="line">            <span class="keyword">if</span> (item.x === head.x &amp;&amp; item.y === head.y) &#123;</span><br><span class="line">                clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">                <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.lists();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//重置游戏</span></span><br><span class="line">    Game.prototype.resetGame = function () &#123;</span><br><span class="line">        clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        <span class="keyword">this</span>.timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.food = new Food();</span><br><span class="line">        <span class="keyword">this</span>.snake = new Snake();</span><br><span class="line">        <span class="keyword">this</span>.food.<span class="keyword">init</span>(ctx);</span><br><span class="line">        <span class="keyword">this</span>.bindKey();</span><br><span class="line">        <span class="keyword">this</span>.time(ctx);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    w.Game = Game;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure>

<h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> canvas = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> game = <span class="keyword">new</span> Game();</span><br><span class="line">  game.startGame(ctx);</span><br><span class="line">  <span class="keyword">var</span> button = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.reset&quot;</span>);</span><br><span class="line">  button.onclick = function () &#123;</span><br><span class="line">    game.resetGame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> pause = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.pause&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> sr = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.src&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> inp = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">&quot;.inp&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  pause.onclick = function () &#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">      a = <span class="number">1</span>;</span><br><span class="line">      game.time(ctx, inp.value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a = <span class="number">0</span>;</span><br><span class="line">      game.pausee();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>源代码地址：<a href="https://github.com/yq6668/code">https://github.com/yq6668/code</a></p>
]]></content>
      <tags>
        <tag>JavaScrip</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>date格式化</title>
    <url>/2021/06/08/date%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-格式化日期对象"><a href="#1-格式化日期对象" class="headerlink" title="1. 格式化日期对象"></a>1. 格式化日期对象</h2><p>格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDate</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//如果date不是日期对象，返回</span></span><br><span class="line">  <span class="keyword">if</span> (!date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> year = d.getFullYear(),</span><br><span class="line">      month = d.getMonth() + <span class="number">1</span>, </span><br><span class="line">      date = d.getDate(), </span><br><span class="line">      hour = d.getHours(), </span><br><span class="line">      minute = d.getMinutes(), </span><br><span class="line">      second = d.getSeconds();</span><br><span class="line">  month = month &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + month : month;</span><br><span class="line">  date = date &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + date : date;</span><br><span class="line">  hour = hour &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + hour : hour;</span><br><span class="line">  minute = minute &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + minute:minute;</span><br><span class="line">  second = second &lt; <span class="number">10</span> ? <span class="string">&#x27;0&#x27;</span> + second:second;</span><br><span class="line">  <span class="keyword">return</span> year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + date + <span class="string">&#x27; &#x27;</span> + hour + <span class="string">&#x27;:&#x27;</span> + minute + <span class="string">&#x27;:&#x27;</span> + second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>计算时间差，返回相差的天/时/分/秒</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//作用求两个日期时间的时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSpaceBetweenDate</span>(<span class="params">date1,date2</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.得到两个日期之间的秒数</span></span><br><span class="line">    <span class="keyword">var</span> between = <span class="built_in">Math</span>.round(<span class="built_in">Math</span>.abs(date1 - date2)/<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//2.把秒数转换成相差多少天  多少小时  多少分钟  多少秒</span></span><br><span class="line">    <span class="keyword">var</span> day = <span class="built_in">Math</span>.floor(between/(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>));</span><br><span class="line">    <span class="keyword">var</span> hour =  <span class="built_in">Math</span>.floor(between/<span class="number">60</span>/<span class="number">60</span>) % <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">var</span> minute = <span class="built_in">Math</span>.floor(between/<span class="number">60</span>)%<span class="number">60</span>;</span><br><span class="line">    <span class="keyword">var</span> second = between%<span class="number">60</span>;</span><br><span class="line">    <span class="comment">//3.包装一个对象返回</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">day</span>:day,</span><br><span class="line">        <span class="attr">hour</span>:hour,</span><br><span class="line">        <span class="attr">minute</span>:minute,</span><br><span class="line">        <span class="attr">second</span>:second</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-8-8 22:23:23&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;2017-10-8 23:30:30&quot;</span>);</span><br><span class="line"><span class="comment">//使用自己写的方法求两个时间的差</span></span><br><span class="line"><span class="keyword">var</span> o = getSpaceBetweenDate(date1,date2);</span><br><span class="line"><span class="built_in">console</span>.log(o);</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>fetch-cookie</title>
    <url>/2021/07/23/fetch-cookie/</url>
    <content><![CDATA[<h2 id="fetch发送请求携带cookie"><a href="#fetch发送请求携带cookie" class="headerlink" title="fetch发送请求携带cookie"></a>fetch发送请求携带cookie</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">const result = fetch(url, &#123;</span><br><span class="line">        <span class="regexp">//</span>fetch不管在同域还是在跨域的情况下，默认都不携带cookie的，所以那些需要权限验证的请求就         无法正常获取到数据，这时候需要配置credentials项，有一下三个选项可添：</span><br><span class="line">        <span class="regexp">//</span>credentials:omit        默认值，忽略cookie的发送</span><br><span class="line">        <span class="regexp">//</span>credentials:same-origin 同源情况会发送cookie</span><br><span class="line">        <span class="regexp">//</span>credentials:include     表示既可以同域发送，也可以跨域发送</span><br><span class="line">        credentials: <span class="string">&#x27;include&#x27;</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js类型判断</title>
    <url>/2021/06/15/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="1-js类型判断"><a href="#1-js类型判断" class="headerlink" title="1. js类型判断"></a>1. js类型判断</h2><h3 id="1-1-js中的数据类型"><a href="#1-1-js中的数据类型" class="headerlink" title="1.1 js中的数据类型"></a>1.1 js中的数据类型</h3><p>基本数据类型：Undefined、Null、Boolean、Number、String，Symbol</p>
<p>引用数据类型 ：Object</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span>  und= <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nul = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;xiaoming&#x27;</span>,<span class="attr">age</span>:<span class="number">22</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)&#125;;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="1-2-typeof"><a href="#1-2-typeof" class="headerlink" title="1.2 typeof"></a>1.2 typeof</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> bool); <span class="comment">//boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str);<span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> und);<span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> nul);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fun);<span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s1); <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure>

<p>typeof可以识别出基本类型boolean,number,undefined,string,symbol，但是不能识别null。不能识别引用数据类型，会把null、array、object统一归为object类型,但是可以识别出function。<br> 所以typeof可以用来识别一些基本类型。</p>
<h3 id="1-3-instanceof"><a href="#1-3-instanceof" class="headerlink" title="1.3 instanceof"></a>1.3 instanceof</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bool <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(num <span class="keyword">instanceof</span> <span class="built_in">Number</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(str <span class="keyword">instanceof</span> <span class="built_in">String</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(und <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(nul <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(fun <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>从结果中看出instanceof不能识别出基本的数据类型 number、boolean、string、undefined、unll、symbol。</p>
<p>但是可以检测出引用类型，如array、object、function，同时对于是使用new声明的类型，它还可以检测出多层继承关系。</p>
<p>其实也很好理解，js的继承都是采用原型链来继承的。比如objA instanceof A ，其实就是看objA的原型链上是否有A的原型，而A的原型上保留A的constructor属性。<br>所以instanceof一般用来检测对象类型，以及继承关系。</p>
<h3 id="1-4-constructor"><a href="#1-4-constructor" class="headerlink" title="1.4 constructor"></a>1.4 constructor</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(bool.constructor === Boolean);// true</span><br><span class="line">console.log(num.constructor === Number);// true</span><br><span class="line">console.log(str.constructor === String);// true</span><br><span class="line">console.log(arr.constructor === Array);// true</span><br><span class="line">console.log(obj.constructor === Object);// true</span><br><span class="line">console.log(fun.constructor === Function);// true</span><br><span class="line">console.log(s1.constructor === Symbol);//true</span><br></pre></td></tr></table></figure>

<p>null、undefined没有construstor方法，因此constructor不能判断undefined和null。<br> 但是他是不安全的，因为contructor的指向是可以被改变。</p>
<h3 id="1-5-Object-prototype-toString-call"><a href="#1-5-Object-prototype-toString-call" class="headerlink" title="1.5 Object.prototype.toString.call"></a>1.5 Object.prototype.toString.call</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(bool));<span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(num));<span class="comment">//[object Number]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str));<span class="comment">//[object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(und));<span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(nul));<span class="comment">//[object Null]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr));<span class="comment">//[object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj));<span class="comment">//[object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(fun));<span class="comment">//[object Function]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(s1)); <span class="comment">//[object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>此方法可以相对较全的判断js的数据类型。</p>
<p>至于在项目中使用哪个判断，还是要看使用场景，具体的选择，一般基本的类型可以选择typeof，引用类型可以使用instanceof。</p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb导入导出</title>
    <url>/2021/06/22/mongodb%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<h2 id="1-MongoDB的导入导出"><a href="#1-MongoDB的导入导出" class="headerlink" title="1.MongoDB的导入导出"></a>1.MongoDB的导入导出</h2><h3 id="1-1-MongoDB的导出功能"><a href="#1-1-MongoDB的导出功能" class="headerlink" title="1.1 MongoDB的导出功能"></a>1.1 MongoDB的导出功能</h3><h4 id="1-1-1-导出单个文件"><a href="#1-1-1-导出单个文件" class="headerlink" title="1.1.1 导出单个文件"></a>1.1.1 导出单个文件</h4><p>mongodb提供了导入和导出的功能，分别是MongoDB下载目录下的mongoexport.exe和mongoimport.exe文件 ，具体的导出命令格式如下：　　　　</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mongoexport -h dbhost -d dbname -c collectionName -o output</span></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<p>-h 数据库地址 </p>
<p>-d 指明使用的库</p>
<p>-c 指明要导出的集合</p>
<p>-o 指明要导出的文件名   文件支持多种格式，如txt,wps,xls等</p>
<p>具体示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.txt</span><br><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.wps</span><br><span class="line">mongoexport -h localhost:<span class="number">27017</span> -d xx -c xx -o C:<span class="regexp">//</span>test.xls</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="1-1-2-导出整个集合"><a href="#1-1-2-导出整个集合" class="headerlink" title="1.1.2 导出整个集合"></a>1.1.2 导出整个集合</h4><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mongodump</span> -h localhost:<span class="number">27017</span> -d xx -o D:\test\</span><br></pre></td></tr></table></figure>



<h3 id="1-2-MongoDB的导入功能"><a href="#1-2-MongoDB的导入功能" class="headerlink" title="1.2 MongoDB的导入功能"></a>1.2 MongoDB的导入功能</h3><p>导入数据可以使用命令：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">mongoimport -h dbhost -d dbname -c collectionname <span class="selector-tag">input</span></span><br></pre></td></tr></table></figure>

<p>参数说明:</p>
<p>-h 数据库地址</p>
<p>-d 指明使用的库</p>
<p>-c 指明要导入的集合   mongodb本身支持隐式创建，故事先无需创建集合</p>
<p>input 文件的地址</p>
<p>具体示例：　</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.txt</span><br><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.wps</span><br><span class="line">mongoimport -h localhost:<span class="number">27017</span> -d xx -c xx C:<span class="regexp">//</span>test.xls</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2021/10/15/ws/</url>
    <content><![CDATA[<h1 id="1-websocket介绍"><a href="#1-websocket介绍" class="headerlink" title="1.websocket介绍"></a>1.websocket介绍</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于 服务器推送技术 的一种。</p>
<ul>
<li><p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>
</li>
<li><p>在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
</li>
<li><p>基于TCP的全双工通信协议</p>
<span id="more"></span></li>
</ul>
<h2 id="1-2-传统的实时通讯方式"><a href="#1-2-传统的实时通讯方式" class="headerlink" title="1.2.传统的实时通讯方式"></a>1.2.传统的实时通讯方式</h2><h3 id="1-2-1-Ajax轮询"><a href="#1-2-1-Ajax轮询" class="headerlink" title="1.2.1.Ajax轮询"></a>1.2.1.Ajax轮询</h3><p>ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。</p>
<h3 id="1-2-2-long-poll"><a href="#1-2-2-long-poll" class="headerlink" title="1.2.2.long poll"></a>1.2.2.long poll</h3><p>long poll其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</p>
<p>总结：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">ajax轮询 需要服务器有很快的处理速度和资源。（速度）</span><br><span class="line">long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</span><br><span class="line"></span><br><span class="line">长连接</span><br><span class="line">在页面里嵌入一个隐蔵<span class="selector-tag">iframe</span>，将这个隐蔵<span class="selector-tag">iframe</span>的<span class="attribute">src</span>属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。</span><br><span class="line">优点：消息即时到达，不发无用请求；管理起来也相对方便。</span><br><span class="line">缺点：服务器维护一个长连接会增加开销，当客户端越来越多的时候，server压力大</span><br><span class="line">实例：Gmail聊天</span><br></pre></td></tr></table></figure>



<h2 id="1-3-和http协议的关系"><a href="#1-3-和http协议的关系" class="headerlink" title="1.3.和http协议的关系"></a>1.3.和http协议的关系</h2><ul>
<li>Websocket是跟HTTP平级的OSI Layer7的协议，绝非基于HTTP，只不过为了兼容互联网现状采用了相同的端口，并利用HTTP消息切入Websocket协议。</li>
<li>Websocket是在TCP上独立设计的全双工，有message概念的通信协议，与HTTP没有任何必然联系。</li>
<li>WebSocket是HTML5出的协议，也就是说HTTP协议没有变化，或者说没关系，但HTTP是不支持持久连接的（长连接，循环连接的不算）</li>
<li>Websocket其实是为了兼容现有浏览器的握手规范，也就是说它是HTTP协议上的一种补充</li>
</ul>
<p><img src="ws%5Cwe-http.png"></p>
<h2 id="1-4-scoket和webscoket"><a href="#1-4-scoket和webscoket" class="headerlink" title="1.4.scoket和webscoket"></a>1.4.scoket和webscoket</h2><h3 id="1-4-1-什么是socket"><a href="#1-4-1-什么是socket" class="headerlink" title="1.4.1.什么是socket"></a>1.4.1.什么是socket</h3><p> 在网络中的两个应用程序（进程）需要全双工相互通信（全双工即双方可同时向对方发送消息），需要用到的就是socket，它能够提供端对端通信，对于程序员来讲，他只需要在某个应用程序的一端（暂且称之为客户端）创建一个socket实例并且提供它所要连接一端（暂且称之为服务端）的IP地址和端口，而另外一端（服务端）创建另一个socket并绑定本地端口进行监听，然后客户端进行连接服务端，服务端接受连接之后双方建立了一个端对端的TCP连接，在该连接上就可 以双向通讯了，而且一旦建立这个连接之后，通信双方就没有客户端服务端之分了，提供的就是端对端通信了。我们可以采取这种方式构建一个桌面版的im程序，让不同主机上的用户发送消息。从本质上来说，socket并不是一个新的协议，它只是为了便于程序员进行网络编程而对tcp/ip协议族通信机制的一种封装。</p>
<h3 id="1-4-2-什么是websocket"><a href="#1-4-2-什么是websocket" class="headerlink" title="1.4.2.什么是websocket"></a>1.4.2.什么是websocket</h3><p>websocket是html5规范中的一个部分，它借鉴了socket这种思想，为web应用程序客户端和服务端之间（注意是客户端服务端）提供了一种全双工通信机制。同时，它又是一种新的应用层协议，websocket协议是为了提供web应用程序和服务端全双工通信而专门制定的一种应用层协议，通常它表示为：ws://echo.websocket.org/?encoding=text HTTP/1.1，可以看到除了前面的协议名和http不同之外，它的表示地址就是传统的url地址。</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">websocket具有以下几个方面的优势：</span><br><span class="line">（<span class="number">1</span>）建立在 TCP 协议之上，服务器端的实现比较容易。</span><br><span class="line">（<span class="number">2</span>）与 HTTP 协议有着良好的兼容性。默认端口也是<span class="number">80</span>和<span class="number">443</span>，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</span><br><span class="line">（<span class="number">3</span>）数据格式比较轻量，性能开销小，通信高效。</span><br><span class="line">（<span class="number">4</span>）可以发送文本，也可以发送二进制数据。</span><br><span class="line">（<span class="number">5</span>）没有同源限制，客户端可以与任意服务器通信。</span><br><span class="line">（<span class="number">6</span>）协议标识符是ws（如果加密，则为wss），服务器网址就是 <span class="built_in">URL</span>。</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><img src="/2021/10/15/ws/xx.jpg"></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line">软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。</span><br><span class="line"></span><br><span class="line"><span class="symbol">Socket</span> 其实并不是一个协议，是应用层与 TCP/<span class="built_in">IP</span> 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 <span class="built_in">IP</span> 协议，<span class="built_in">IP</span> 协议的连接则依赖于链路层等更低层次。</span><br><span class="line"></span><br><span class="line"><span class="symbol">WebSocket</span> 则是一个典型的应用层协议。</span><br><span class="line"></span><br><span class="line">总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。</span><br></pre></td></tr></table></figure>



<h2 id="1-5-webscoket的通信原理和机制"><a href="#1-5-webscoket的通信原理和机制" class="headerlink" title="1.5.webscoket的通信原理和机制"></a>1.5.webscoket的通信原理和机制</h2><p>正常http的get请求：</p>
<p><img src="/2021/10/15/ws/requrie.png"></p>
<h3 id="1-5-1-客户端：申请协议升级"><a href="#1-5-1-客户端：申请协议升级" class="headerlink" title="1.5.1.客户端：申请协议升级"></a>1.5.1.客户端：申请协议升级</h3><p>WebSocket复用了HTTP的握手通道。具体指的是，客户端通过HTTP请求与WebSocket服务端协商升级协议。协议升级完成后，后续的数据交换则遵照WebSocket的协议。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://127.0.0.1:3000</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>w4v7O6xFTi36lq3RNcgctw==</span><br></pre></td></tr></table></figure>

<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">重点请求首部意义如下：</span><br><span class="line"></span><br><span class="line"><span class="symbol">Connection:</span> Upgrade：表示要升级协议</span><br><span class="line"><span class="symbol">Upgrade:</span> websocket：表示要升级到websocket协议。</span><br><span class="line"><span class="keyword">Sec</span>-WebSocket-Version: <span class="number">13</span>：表示websocket的版本。如果服务端不支持该版本，需要返回一个<span class="keyword">Sec</span>-WebSocket-Versionheader，里面包含服务端支持的版本号。</span><br><span class="line"><span class="keyword">Sec</span>-WebSocket-Key：与后面服务端响应首部的<span class="keyword">Sec</span>-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-服务端：响应协议升级"><a href="#1-5-2-服务端：响应协议升级" class="headerlink" title="1.5.2.服务端：响应协议升级"></a>1.5.2.服务端：响应协议升级</h3><p>服务端返回内容如下，状态代码<code>101</code>表示协议切换。到此完成协议升级，后续的数据交互都按照新的协议来。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">HTTP</span>/<span class="number">1</span>.<span class="number">1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span>:Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Sec</span>-WebSocket-Accept: Oy<span class="number">4</span>NRAQ<span class="number">13</span>jhfONC<span class="number">7</span>bP<span class="number">8</span>dTKb<span class="number">4</span>PTU=</span><br></pre></td></tr></table></figure>

<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Sec</span>-WebSocket-Accept根据客户端请求首部的Sec-WebSocket-Key计算出来。</span><br><span class="line"><span class="attribute">toBase64</span>( sha<span class="number">1</span>( Sec-WebSocket-Key + <span class="number">258</span>EAFA<span class="number">5</span>-E<span class="number">914</span>-<span class="number">47</span>DA-<span class="number">95</span>CA-C<span class="number">5</span>AB<span class="number">0</span>DC<span class="number">85</span>B<span class="number">11</span> )  )</span><br></pre></td></tr></table></figure>

<h1 id="2-websocket的简单使用"><a href="#2-websocket的简单使用" class="headerlink" title="2.websocket的简单使用"></a>2.websocket的简单使用</h1><h2 id="2-1-websocket的创建"><a href="#2-1-websocket的创建" class="headerlink" title="2.1.websocket的创建"></a>2.1.websocket的创建</h2><figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">以下 API 用于创建 WebSocket 对象。</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Socket = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>, [protocol] );</span><br><span class="line">以上代码中的第一个参数 <span class="built_in">url</span>, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。</span><br><span class="line"></span><br><span class="line">websocket 可以跟 HTTP 协议共用一个端口，它协议的前缀是 <span class="attribute">ws</span>:<span class="comment">//，如果是 HTTPS，那么就是 wss://，    webSocket 没有同源限制，客户端可以发送任意请求到服务端，只要目标服务器允许。</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-websocket的属性和方法"><a href="#2-2-websocket的属性和方法" class="headerlink" title="2.2.websocket的属性和方法"></a>2.2.websocket的属性和方法</h2><p>以下是 WebSocket 对象的属性。假定我们使用了以上代码创建了 Socket 对象：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Socket.readyState</td>
<td align="left">只读属性 <strong>readyState</strong> 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</td>
</tr>
<tr>
<td align="left">Socket.bufferedAmount</td>
<td align="left">只读属性 <strong>bufferedAmount</strong> 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</td>
</tr>
</tbody></table>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CONNECTING</span>：值为<span class="number">0</span>，表示正在连接。</span><br><span class="line"></span><br><span class="line"><span class="attribute">OPEN</span>：值为<span class="number">1</span>，表示连接成功，可以通信了。</span><br><span class="line"></span><br><span class="line"><span class="attribute">CLOSING</span>：值为<span class="number">2</span>，表示连接正在关闭。</span><br><span class="line"></span><br><span class="line"><span class="attribute">CLOSED</span>：值为<span class="number">3</span>，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>



<p>以下是 WebSocket 对象的相关事件。</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">事件处理程序</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">open</td>
<td align="left">Socket.onopen</td>
<td align="left">连接建立时触发</td>
</tr>
<tr>
<td align="left">message</td>
<td align="left">Socket.onmessage</td>
<td align="left">客户端接收服务端数据时触发</td>
</tr>
<tr>
<td align="left">error</td>
<td align="left">Socket.onerror</td>
<td align="left">通信发生错误时触发</td>
</tr>
<tr>
<td align="left">close</td>
<td align="left">Socket.onclose</td>
<td align="left">连接关闭时触发</td>
</tr>
</tbody></table>
<p>以下是 WebSocket 对象的相关方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Socket.send()</td>
<td>使用连接发送数据</td>
</tr>
<tr>
<td>Socket.close()</td>
<td>关闭连接</td>
</tr>
</tbody></table>
<p><strong>websocket的使用</strong></p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="built_in">url</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ws.readyState == ws.CONNECTING) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;连接正在打开&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.send(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">    <span class="comment">//可以看到 &quot;连接正在打开&quot;并没有被打印，说明open对应的就是OPEN状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.CONNECTING) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接正在打开1&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.OPEN) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接已打开&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到消息后触发</span></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ws.send(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接关闭时触发</span></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ws.readyState == ws.CLOSED) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;连接已关闭&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接错误时触发</span></span><br><span class="line">ws.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>(err);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.close();</span><br></pre></td></tr></table></figure>

<h2 id="2-3-node-js使用ws模块的WebSocket服务"><a href="#2-3-node-js使用ws模块的WebSocket服务" class="headerlink" title="2.3.node.js使用ws模块的WebSocket服务"></a>2.3.node.js使用ws模块的WebSocket服务</h2><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">安装<span class="keyword">ws</span>模块</span><br><span class="line">npm install <span class="keyword">ws</span> --save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">&#x27;ws&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> WebSocketServer = WebSocket.Server;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 websocket 服务器 监听在 3000 端口</span></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123;<span class="attr">port</span>: <span class="number">3000</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器被客户端连接</span></span><br><span class="line">wss.on(<span class="string">&#x27;connection&#x27;</span>, <span class="function">(<span class="params">ws</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 ws 对象，就可以获取到客户端发送过来的信息和主动推送信息给客户端</span></span><br><span class="line"></span><br><span class="line">    ws.on(<span class="string">&#x27;massage&#x27;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//msg是我们从客户端受到的消息</span></span><br><span class="line">        ws.send(msg, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-1-事件监听"><a href="#2-3-1-事件监听" class="headerlink" title="2.3.1.事件监听"></a>2.3.1.事件监听</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">一般语法：.<span class="keyword">on</span>(“<span class="keyword">event</span>”, funcion)</span><br><span class="line">这是ws服务器的事件监听</span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">connection事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;connection&quot;</span>, <span class="function"><span class="params">(socket, request)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当握手完成后会发出，socket参数为WebSocket类型，request为http.IncomingMessage类型</span><br><span class="line">一般在这个事件中通过socket.<span class="literal">on</span>注册socket的事件</span><br><span class="line"></span><br><span class="line">error事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">(error)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当依赖的httpServer出现错误时发出，error为<span class="built_in">Error</span>类型</span><br><span class="line"></span><br><span class="line">headers事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;headers&quot;</span>, <span class="function"><span class="params">(headers, request)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">握手事件中，服务器即将响应请求时会发出这个事件，可以在方法中对headers进行修改</span><br><span class="line">headers为数组类型，request为http.IncomingMessage类型</span><br><span class="line"></span><br><span class="line">listening事件</span><br><span class="line">var wss = <span class="keyword">new</span> ws.Server(&#123;port: <span class="number">3000</span>&#125;);</span><br><span class="line">wss.<span class="literal">on</span>(<span class="string">&quot;listening&quot;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当绑定依赖的httoServer时发出</span><br></pre></td></tr></table></figure>

<h3 id="2-3-2-实例的监听事件"><a href="#2-3-2-实例的监听事件" class="headerlink" title="2.3.2.实例的监听事件"></a>2.3.2.实例的监听事件</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">一般语法： websocket.<span class="keyword">on</span>(“event”, <span class="function"><span class="keyword">Function</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function">无论是客户端还是服务端的实例都需要监听事件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">message 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当收到消息时发出，data 类型为 <span class="built_in">String</span>|Buffer|<span class="built_in">ArrayBuffer</span>|Buffer[]</span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line">JavaScript 语言没有读取或操作二进制数据流的机制。</span><br><span class="line">Node.js 中引入了 Buffer 类型使我们可以操作 TCP流 或 文件流。</span><br><span class="line">Buffer 类型的对象类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。（ buf.length 是固定的，不允许修改 ）</span><br><span class="line">Buffer 是全局的，所以使用的时候无需 <span class="built_in">require</span>() 的方式来加载</span><br><span class="line">--------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">close 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="params">(code, reason)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">当连接断开时发出</span><br><span class="line"></span><br><span class="line">error 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">(error)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">open 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;open&quot;</span>, <span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">连接建立成功时发出</span><br><span class="line"></span><br><span class="line">ping 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;ping&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">收到ping消息时发出，data为Buffer类型</span><br><span class="line"></span><br><span class="line">pong 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;pong&quot;</span>, <span class="function"><span class="params">(data)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">收到pong消息时发出，data为Buffer类型</span><br><span class="line"></span><br><span class="line">注：ping，pong事件通常用来检测连接是否仍联通，由客户端(服务端)发出一个ping事件，服务端（客户端）收到后回复一个pong事件，客户端（服务端）收到后就知道连接仍然联通</span><br><span class="line"></span><br><span class="line">unexpected-response 事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;unexpected-response&quot;</span>, <span class="function"><span class="params">(request, response)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">request &#123;http.ClientRequest&#125; response &#123;http.IncomingMessage&#125;</span><br><span class="line">当服务端返回的报文不是期待的结果，例如<span class="number">401</span>，则会发出这个事件，如果这个事件没有被监听，则会抛出一个错误</span><br><span class="line"></span><br><span class="line">upgrade事件</span><br><span class="line">websocket.<span class="literal">on</span>(<span class="string">&quot;upgrade&quot;</span>, <span class="function"><span class="params">(response)</span>=&gt;</span>&#123;&#125;);</span><br><span class="line">response &#123;http.IncomingMessage&#125;</span><br><span class="line">握手过程中，当收到服务端回复时发出该事件，你可以在response中查看cookie等header</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>websocket</category>
      </categories>
      <tags>
        <tag>JavaScrip</tag>
        <tag>websocket</tag>
      </tags>
  </entry>
</search>
